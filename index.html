<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>chubby chunklet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Icons -->
  <link rel="icon" type="image/png" href="favicon.png" />
  <link rel="apple-touch-icon" href="favicon.png" />

  <!-- Fonts: Rubik for UI/HUD; Emilys Candy for the bubble text -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Emilys+Candy&family=Rubik:wght@400;500;700&display=swap" rel="stylesheet" />

  <style>
    :root{
      /* Backend */
      --endpoint: https://pu30nzsu59.execute-api.us-east-1.amazonaws.com/dev/chunklet;

      /* Chunklet sprite / mouth (calibrated) */
      --figure-scale:1.15;
      --mouth-top:39%;
      --mouth-left:49%;
      --mouth-w:20px;
      --mouth-h:20px;
      --mouth-scale-0:.05;

      /* Typing */
      --char-ms:18;

      /* Door anchors (normalized, calibrated) */
      --door-x: 0.472;
      --door-y: 0.579;
      --door-w: 0.099;
      --door-h: 0.248;

      /* Bubble layout */
      --output-top-fallback: 8vmin; /* starting spot; JS lifts it further if needed */
      --bubble-gap: 18px;           /* min space between bubble bottom and Chunklet top */
      --tail-x: 50%;                /* updated dynamically */
    }

    *{box-sizing:border-box}
    html,body{
      margin:0;padding:0;
      font-family:Rubik, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background:#000;color:#fff; -webkit-font-smoothing:antialiased;
      overflow:hidden; height:100%; width:100%;
    }

    .scene-container{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:#4a7ba7; }
    .scene-bg{ width:100%; height:100%; position:relative; display:flex; align-items:center; justify-content:center; perspective:900px; }
    .scene-bg img{ width:100%; height:100%; object-fit:cover; display:block; user-select:none; -webkit-user-drag:none; }

    /* Door (CSS fallback so it's visible even if JS hasn't run yet) */
    .door-container{
      position:absolute; left:50%; top:52%; width:140px; height:180px;
      transform:translate(-50%, -50%); cursor:pointer; z-index:50;
    }
    .door-left, .door-right{
      position:absolute; width:50%; height:100%;
      background:#3d2418; border:3px solid #2d1810;
      transition:transform 0.8s cubic-bezier(0.68,-0.55,0.265,1.55);
      box-shadow: inset 0 0 20px rgba(0,0,0,0.4), 0 0 10px rgba(0,0,0,0.8);
      backface-visibility:hidden; transform-style:preserve-3d;
    }
    .door-left{ left:0;  transform-origin:left center;  border-right:2px solid #1a0e08; }
    .door-right{right:0;  transform-origin:right center; border-left: 2px solid #1a0e08; }
    .door-panel{ position:absolute; background:#2d1810; border:2px solid #1a0e08;
      box-shadow: inset 2px 2px 4px rgba(0,0,0,0.4), inset -1px -1px 2px rgba(61,36,24,0.3); }
    .door-left .panel-top{   width:65%; height:22%; top:15%; left:17.5%;}
    .door-left .panel-mid{   width:65%; height:22%; top:41%; left:17.5%;}
    .door-left .panel-bottom{width:65%; height:22%; top:67%; left:17.5%;}
    .door-right .panel-top{   width:65%; height:22%; top:15%; right:17.5%;}
    .door-right .panel-mid{   width:65%; height:22%; top:41%; right:17.5%;}
    .door-right .panel-bottom{width:65%; height:22%; top:67%; right:17.5%;}
    .door-open .door-left{ transform:rotateY(85deg); }
    .door-open .door-right{ transform:rotateY(-85deg); }

    /* Chunklet */
    .chunklet-container{
      position:absolute; transform:translate(-50%, -30px);
      opacity:0; transition:opacity 0.3s; z-index:60; pointer-events:none;
    }
    .chunklet-container.active{ opacity:1; }
    .chunklet-wrap{ position:relative; width:calc(100px*var(--figure-scale)); height:calc(130px*var(--figure-scale)); display:flex; align-items:flex-end; justify-content:center; }
    .chunklet-img{ width:calc(90px*var(--figure-scale)); max-width:100%; user-select:none; -webkit-user-drag:none; filter:drop-shadow(0 8px 16px rgba(0,0,0,.6)); image-rendering:-webkit-optimize-contrast; }

    /* Ground shadow */
    .ground-shadow{
      position:absolute; left:50%; bottom:-2px; width:88px; height:18px; transform:translateX(-50%) scale(0.6);
      background:radial-gradient(ellipse at center, rgba(0,0,0,.45) 0%, rgba(0,0,0,.25) 40%, rgba(0,0,0,0) 70%);
      filter:blur(2px); opacity:0; pointer-events:none;
    }

    /* Mouth overlay */
    .mouth-overlay{ position:absolute; top:var(--mouth-top); left:var(--mouth-left); width:var(--mouth-w); height:var(--mouth-h); transform:translate(-50%,-50%); display:flex; align-items:center; justify-content:center; pointer-events:none; }
    .mouth-overlay svg{width:100%;height:100%}
    #mouth{transform-origin:50% 50%; transform:scale(1, var(--mouth-scale-0))}

    /* ===== Speech bubble (Peanuts-style) ===== */
    .output-container{
      position:fixed; left:50%; transform:translateX(-50%);
      /* allow the bubble to size to content (but cap the width) */
      width:auto; max-width:90vw;
      z-index:40; opacity:0; transition:opacity 0.5s;
      pointer-events:none; top:var(--output-top-fallback);
      text-align:center; /* centers inline bubble when it’s narrower */
    }
    .output-container.active{ opacity:1; }

    .bubble-wrap{ position:relative; display:inline-block; }
    .speech-bubble{
      position:relative;
      background:#fff;
      border:6px solid #000;
      border-radius:32px;
      padding:18px 26px 18px 22px; /* tighter all around + room for emoji */
      color:#111;
      box-shadow:0 6px 0 #000, 0 14px 30px rgba(0,0,0,.35);
      display:inline-block;
      max-width:86vw; /* wrapping cap */
    }
    /* Rounded tail via SVG (stroke = outline) */
    .bubble-tail{
      position:absolute;
      bottom:-2px;  /* overlaps slightly so stroke connects */
      left:var(--tail-x);
      transform:translate(-50%, 100%); /* place below bubble edge */
      width:44px; height:28px;
      overflow:visible; pointer-events:none;
    }

    /* Freeze toggle emoji — minimal, inside bubble */
    .freeze-emoji{
      position:absolute;
      top:6px; right:8px;
      display:none;
      font-size:18px; line-height:1;
      background:transparent; border:none;
      cursor:pointer; user-select:none;
    }
    .output-container.active .freeze-emoji{ display:block; pointer-events:auto; }

    /* Speech text — Emilys Candy + very tight tracking */
    .output{
      font-family:"Emilys Candy", Rubik, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      text-transform:uppercase;
      font-weight:400;
      font-size:clamp(22px, 2.4vw, 36px);
      line-height:1.04;
      letter-spacing:-0.06em;
      word-spacing:-0.04em;
      color:#111;
      margin:0;
      white-space:pre-wrap;
      text-shadow:none;
      text-align:center;
    }
    .cursor{
      display:inline-block; width:.5ch; height:1.05em; background:#111;
      vertical-align:text-bottom; animation:blink 1s steps(1,end) infinite; border-radius:2px;
    }
    @keyframes blink{0%,55%{opacity:1}56%,100%{opacity:0}}
    .typing .cursor{animation:none}

    /* Attribution — match tracking to phrase */
    .output .work-tag{
      opacity:.95; text-transform:uppercase;
      margin-left:.6em; font-size:.62em;
      letter-spacing:-0.06em;
      word-spacing:-0.04em;
      color:#333; display:block; margin-top:10px; text-shadow:none;
    }

    /* ===== Dramatic entrance (unchanged) ===== */
    @keyframes emergePop {
      0%   { transform:translate(-50%,-60px) scale(.86,.92) rotate(-3deg); opacity:0; filter:brightness(.85); }
      40%  { transform:translate(-50%,-28px) scale(1.06,.94) rotate(-2deg); opacity:1; }
      60%  { transform:translate(-50%,-18px) scale(.96,1.04) rotate(2deg); }
      100% { transform:translate(-50%,-12px) scale(1,1) rotate(0deg); }
    }
    @keyframes waddleDown {
      0%   { transform:translate(-50%,-12px) rotate(0deg); }
      10%  { transform:translate(-50%,   0px) rotate(-3deg); }
      20%  { transform:translate(-50%,  10px) rotate(3deg); }
      30%  { transform:translate(-50%,  20px) rotate(-3deg); }
      40%  { transform:translate(-50%,  30px) rotate(3deg); }
      55%  { transform:translate(-50%,  45px) rotate(-2deg); }
      70%  { transform:translate(-50%,  58px) rotate(2deg); }
      85%  { transform:translate(-50%,  66px) rotate(-1deg) scale(1.02,.98); }
      100% { transform:translate(-50%,  70px) rotate(0deg)  scale(1,1); }
    }
    @keyframes shadowEmerge { 0%{opacity:0; transform:translateX(-50%) scale(0.4);} 60%{opacity:.55; transform:translateX(-50%) scale(0.75);} 100%{opacity:.65; transform:translateX(-50%) scale(0.85);} }
    @keyframes shadowWaddle { 0%{opacity:.65; transform:translateX(-50%) scale(0.85);} 25%{opacity:.70; transform:translateX(-50%) scale(0.95);} 50%{opacity:.60; transform:translateX(-50%) scale(0.88);} 75%{opacity:.72; transform:translateX(-50%) scale(1.00);} 100%{opacity:.68; transform:translateX(-50%) scale(1.05);} }
    .chunklet-container.emerge { animation:emergePop .7s cubic-bezier(.22,1,.36,1) forwards; }
    .chunklet-container.waddle { animation:waddleDown 2.4s cubic-bezier(.22,1,.36,1) forwards; }
    .chunklet-container.emerge .ground-shadow { animation:shadowEmerge .7s ease-out forwards; }
    .chunklet-container.waddle .ground-shadow { animation:shadowWaddle 2.4s ease-out forwards; }

    /* Calibration HUD */
    .cal-hud{ position:fixed; left:8px; bottom:8px; font:12px/1.3 Rubik, ui-monospace, Menlo, Consolas, monospace; background:rgba(0,0,0,.6); color:#0ff; padding:8px 10px; border:1px solid rgba(0,255,255,.35); border-radius:6px; pointer-events:none; opacity:0; transition:opacity .15s; white-space:pre; z-index:100; }
    .cal-hud.on{ opacity:1; }

    @media(max-width:600px){
      .output-container{ max-width:94vw; }
      .speech-bubble{ border-radius:28px; padding:14px 18px 14px 16px; }
      .output{ font-size:clamp(18px, 4.1vw, 28px); letter-spacing:-0.06em; line-height:1.07; }
      .freeze-emoji{ top:4px; right:6px; font-size:16px; }
    }
  </style>
</head>
<body>
  <audio id="clickSnd" src="click.mp3" preload="auto"></audio>

  <div class="scene-container">
    <div class="scene-bg">
      <img src="skullbones.png" alt="Scene background" />

      <!-- Door -->
      <div class="door-container" id="doorTrigger" aria-label="Open the door" role="button" tabindex="0">
        <div class="door-left">
          <div class="door-panel panel-top"></div>
          <div class="door-panel panel-mid"></div>
          <div class="door-panel panel-bottom"></div>
        </div>
        <div class="door-right">
          <div class="door-panel panel-top"></div>
          <div class="door-panel panel-mid"></div>
          <div class="door-panel panel-bottom"></div>
        </div>
      </div>

      <!-- Chunklet -->
      <div class="chunklet-container" id="chunkletContainer" aria-hidden="true">
        <div class="chunklet-wrap">
          <img src="littleboytalk.png" alt="Chubby Chunklet" class="chunklet-img" />
          <div class="mouth-overlay">
            <svg viewBox="0 0 100 100" aria-hidden="true">
              <ellipse id="mouth" cx="50" cy="50" rx="26" ry="24" fill="#111"/>
            </svg>
          </div>
          <div class="ground-shadow"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Speech bubble output -->
  <div class="output-container" id="outputContainer" aria-live="polite">
    <div class="bubble-wrap">
      <div class="speech-bubble" id="bubble">
        <div class="output" id="output">
          <span id="typed"></span><span id="cursor" class="cursor"></span>
        </div>
        <div id="freezeEmoji" class="freeze-emoji" title="Freeze">❄️</div>
      </div>
      <!-- SVG rounded tail -->
      <svg class="bubble-tail" id="bubbleTail" viewBox="0 0 44 28" preserveAspectRatio="xMidYMid meet" aria-hidden="true">
        <path d="M4,2 C 14,20 30,20 40,2" fill="#fff" stroke="#000" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </div>
  </div>

  <!-- Calibration HUD -->
  <div class="cal-hud" id="calHud"></div>

  <script>
    /* ===== CONFIG & Timings ===== */
    const css = getComputedStyle(document.documentElement);
    const ENDPOINT = (css.getPropertyValue('--endpoint') || '').trim() ||
      'https://pu30nzsu59.execute-api.us-east-1.amazonaws.com/dev/chunklet';
    const QUERY    = '?style=canon&modern=0&accent=scottish';
    const CHAR_MS  = parseInt(css.getPropertyValue('--char-ms'),10) || 20;

    const DOOR_SWING_MS = 800, EMERGE_MS = 700, WADDLE_MS = 2400;

    const doorTrigger       = document.getElementById('doorTrigger');
    const chunkletContainer = document.getElementById('chunkletContainer');
    const outputContainer   = document.getElementById('outputContainer');
    const bubble            = document.getElementById('bubble');
    const bubbleTail        = document.getElementById('bubbleTail');
    const typed             = document.getElementById('typed');
    const cursor            = document.getElementById('cursor');
    const mouth             = document.getElementById('mouth');
    const output            = document.getElementById('output');
    const clickSnd          = document.getElementById('clickSnd');
    const freezeEmoji       = document.getElementById('freezeEmoji');

    const bgImg   = document.querySelector('.scene-bg img');
    const host    = document.querySelector('.scene-bg');
    const isIOS   = /iP(hone|od|ad)|Macintosh.*Mobile/.test(navigator.userAgent);

    let busy=false, doorOpen=false, frozen=false;
    let audioCtx,currentSource,audioEl,mediaSource,analyser,timeData;
    let raf,animating=false,tagPlaying=false;
    let currentObjectURL=null, iosAudioInitialized=false;

    /* ===== micro scheduler: kill stale timeouts to avoid early closes ===== */
    const timers = new Set();
    function delay(ms, fn){
      const id = setTimeout(()=>{ timers.delete(id); fn && fn(); }, ms);
      timers.add(id); return id;
    }
    function clearTimers(){ for(const id of timers) clearTimeout(id); timers.clear(); }

    /* ===== mouth anim bands ===== */
    const SY=[0.07,0.55,1.10,1.70,2.30], SX=[1.00,1.01,1.02,1.02,1.03];
    const THRESH_UP=[0.030,0.060,0.100,0.160], HYST_DELTA=0.018;
    const THRESH_DOWN=THRESH_UP.map(t=>Math.max(0,t-HYST_DELTA));
    const GATE_FLOOR=0.010, CLOSE_GRACE_MS=20;
    let level=0,lastChange=0;

    function ensureCtx(){ if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); if(audioCtx.state==='suspended') audioCtx.resume(); }
    function ensureAnalyser(){ ensureCtx(); if(!analyser){ analyser=audioCtx.createAnalyser(); analyser.fftSize=256; analyser.smoothingTimeConstant=0.0; timeData=new Float32Array(analyser.fftSize);} }
    function attachAnalyserToBufferSource(src){ ensureAnalyser(); try{src.disconnect();}catch(_){ } src.connect(analyser); analyser.connect(audioCtx.destination); }
    function attachAnalyserToMediaElement(){
      ensureAnalyser();
      if(isIOS && !iosAudioInitialized){ initializeIOSAudio(); return; }
      if(!audioEl){
        audioEl=document.createElement('audio');
        audioEl.style.position='absolute'; audioEl.style.left='-9999px';
        audioEl.setAttribute('playsinline',''); audioEl.setAttribute('webkit-playsinline','');
        document.body.appendChild(audioEl);
      }
      if(!mediaSource && audioCtx && audioEl){
        try{ mediaSource=audioCtx.createMediaElementSource(audioEl); mediaSource.connect(analyser); analyser.connect(audioCtx.destination); }
        catch(e){ console.warn('createMediaElementSource failed', e); }
      }
    }
    function rmsLevel(){ if(!analyser||!timeData) return 0; analyser.getFloatTimeDomainData(timeData); let s=0; for(let i=0;i<timeData.length;i++){s+=timeData[i]*timeData[i]} let r=Math.sqrt(s/timeData.length); return r<GATE_FLOOR?0:r; }
    function setLevel(n){ n=Math.max(0,Math.min(4,n|0)); if(n===level) return; level=n; mouth.style.transform=`scale(${SX[level]}, ${SY[level]})`; lastChange=performance.now(); }
    function setClosed(){ setLevel(0); }
    function startMouth(){ if(animating) return; animating=true; raf=requestAnimationFrame(tick); }
    function stopMouth(){ animating=false; cancelAnimationFrame(raf); setClosed(); }
    function tick(){
      if(!animating) return; raf=requestAnimationFrame(tick);
      const active=!!currentSource||tagPlaying, now=performance.now();
      if(active){
        if(analyser && (currentSource || (tagPlaying && mediaSource))){
          const e=rmsLevel();
          if(isIOS && e===0 && tagPlaying){ const t=(now/1000); const phase=((t*15)|0)%5; setLevel([1,2,3,2,1][phase]); return; }
          let target=level;
          while(target<4 && e>=THRESH_UP[target]) target++;
          while(target>0 && e<THRESH_DOWN[target-1]) target--;
          if(target<level && (now-lastChange)<CLOSE_GRACE_MS) target=level;
          setLevel(target);
        }else{ const t=(now/1000); const phase=((t*15)|0)%5; setLevel([1,2,3,2,1][phase]); }
        return;
      }
      const t=(now/1000); const phase=((t*13)|0)%4; const rand=Math.random();
      setLevel(phase===0?0:phase===1?(rand<.7?1:2):phase===2?(rand<.6?2:3):(rand<.5?3:4));
    }

    function initializeIOSAudio(){
      if(iosAudioInitialized) return;
      try{
        ensureCtx();
        if(!audioEl){
          audioEl=document.createElement('audio');
          audioEl.style.position='absolute'; audioEl.style.left='-9999px';
          audioEl.setAttribute('playsinline',''); audioEl.setAttribute('webkit-playsinline',''); document.body.appendChild(audioEl);
        }
        const silent='data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjQ1LjEwMAAAAAAAAAAAAAAA//tQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAACAAABhgC7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u////////////////////////////////////////////////////////AAAAAExhdmY1OC40NS4xMDAAAAAAAAAAAAAAAAAAAAAkAAAAAAAAAAAAYYZn5GDeAAAAAAD/+1DEAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAACAAABhgC7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u////////////////////////////////////////////////////////AAAAAExhdmY1OC40NS4xMDAAAAAAAAAAAAAAAAAAAAAkAAAAAAAAAAABhmfkYN4AAAAAAP/7UMQAA8AAAGkAAAAIAAANIAAAARMQU1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA';
        audioEl.src=silent; audioEl.load();
        const p=audioEl.play();
        if(p!==undefined){
          p.then(()=>{ audioEl.pause(); audioEl.currentTime=0;
            if(!mediaSource && audioCtx){
              try{ mediaSource=audioCtx.createMediaElementSource(audioEl); ensureAnalyser(); mediaSource.connect(analyser); analyser.connect(audioCtx.destination); iosAudioInitialized=true; }
              catch(e){ console.warn('iOS audio init partial success, no analyser:', e); }
            }
          }).catch(e=>console.warn('iOS audio init failed',e));
        }
      }catch(e){ console.warn('iOS audio initialization error:', e); }
    }
    function unlockAudioOnce(){
      try{
        ensureCtx();
        if(isIOS){ initializeIOSAudio(); }
        else { const buf=audioCtx.createBuffer(1,1,22050); const src=audioCtx.createBufferSource(); src.buffer=buf; src.connect(audioCtx.destination); src.start(0); }
      }catch(_){}
      document.removeEventListener('touchstart', unlockAudioOnce);
      document.removeEventListener('click', unlockAudioOnce);
    }
    document.addEventListener('touchstart', unlockAudioOnce, {once:true, passive:true});
    document.addEventListener('click', unlockAudioOnce, {once:true});

    const sanitize = txt=>{ txt=(txt||'').trim().replace(/!+$/,'').replace(/\s+/g,' '); return /[.?!]$/.test(txt)?txt:txt+'.'; };

    function typeOut(text, done){
      typed.textContent='';
      output.classList.add('typing');
      (function loop(i=0){
        typed.textContent = text.slice(0,i);
        placeBubble(); // keep bubble clear of Chunklet as text wraps
        if(i<text.length){
          setTimeout(()=>loop(i+1), CHAR_MS + ((i%7)?0:Math.random()*10));
        }else{
          output.classList.remove('typing');
          placeBubble();
          done && done();
        }
      })();
    }

    function stopAudio(){
      if(currentSource){ try{currentSource.stop();}catch(_){ } try{currentSource.disconnect();}catch(_){ } currentSource=null; }
      if(audioEl){ try{ audioEl.pause(); audioEl.currentTime=0; }catch(_){ } }
      if(currentObjectURL){ URL.revokeObjectURL(currentObjectURL); currentObjectURL=null; }
      tagPlaying=false;
    }

    function showWork(work, author){
      const old = document.querySelector('#output .work-tag'); if(old) old.remove();
      if(!work && !author) return;
      const span=document.createElement('span'); span.className='work-tag';
      span.textContent='— '+[work,author].filter(Boolean).join(' · ');
      document.getElementById('output').appendChild(span);
    }

    /* Door/chunklet normalized positioning */
    const DOOR={
      get x(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--door-x'))||0.5; },
      get y(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--door-y'))||0.55; },
      get w(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--door-w'))||0.10; },
      get h(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--door-h'))||0.25; }
    };

    function positionDoorAndChunklet(){
      const hostRect=host.getBoundingClientRect();
      const natW=bgImg.naturalWidth, natH=bgImg.naturalHeight;

      const scale = (natW&&natH) ? Math.max(hostRect.width/natW, hostRect.height/natH) : 1;
      const dispW = (natW||hostRect.width)*scale;
      const dispH = (natH||hostRect.height)*scale;
      const offsetX=(hostRect.width-dispW)/2, offsetY=(hostRect.height-dispH)/2;

      const cx = hostRect.left + offsetX + dispW*DOOR.x;
      const cy = hostRect.top  + offsetY + dispH*DOOR.y;
      const dw = dispW*DOOR.w, dh = dispH*DOOR.h;

      Object.assign(doorTrigger.style, { left:(cx-hostRect.left)+'px', top:(cy-hostRect.top)+'px', width:dw+'px', height:dh+'px' });

      const exitY = cy + dh*0.35;
      Object.assign(chunkletContainer.style, { left:(cx-hostRect.left)+'px', top:(exitY-hostRect.top)+'px', transform:'translate(-50%,-30px)' });

      placeBubble();
    }

    /* Bubble placement: keeps bubble above Chunklet + aims tail */
    function placeBubble(){
      const cardRect = outputContainer.getBoundingClientRect();
      const guyRect  = chunkletContainer.getBoundingClientRect();
      if(!(cardRect.width && guyRect.width)) return;

      const desiredBottom = Math.max(8, guyRect.top - parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--bubble-gap')));
      const newTop = Math.max(8, Math.round(desiredBottom - cardRect.height));
      outputContainer.style.top = newTop + 'px';

      const cardLeft = cardRect.left;
      const tailPx = (guyRect.left + guyRect.width/2) - cardLeft;
      const tailPct = Math.max(8, Math.min(92, tailPx / cardRect.width * 100));
      outputContainer.style.setProperty('--tail-x', tailPct + '%');
    }

    const ro = new ResizeObserver(()=>placeBubble());
    ro.observe(outputContainer);

    function onReadyToPosition(){
      positionDoorAndChunklet();
      setTimeout(positionDoorAndChunklet, 50);
      setTimeout(positionDoorAndChunklet, 250);
    }
    if(bgImg.complete) onReadyToPosition(); else bgImg.addEventListener('load', onReadyToPosition);
    window.addEventListener('resize', positionDoorAndChunklet);
    window.addEventListener('orientationchange', positionDoorAndChunklet);

    /* Door choreography */
    function openDoor(){
      if(doorOpen) return;
      positionDoorAndChunklet();
      doorOpen=true; doorTrigger.classList.add('door-open');

      setTimeout(()=>{
        chunkletContainer.classList.add('active','emerge');
        setTimeout(()=>{
          chunkletContainer.classList.remove('emerge');
          chunkletContainer.classList.add('waddle');
          setTimeout(()=>{
            outputContainer.classList.add('active');
            placeBubble();
          }, WADDLE_MS);
        }, EMERGE_MS);
      }, DOOR_SWING_MS);
    }
    function closeDoor(){
      if(!doorOpen) return; doorOpen=false;
      chunkletContainer.classList.remove('active','emerge','waddle');
      outputContainer.classList.remove('active');
      setTimeout(()=>{ doorTrigger.classList.remove('door-open'); busy=false; }, 500);
    }

    /* TTS playback */
    async function playAudio(b64,onEnd){
      if(isIOS){
        try{
          ensureCtx();
          if(!iosAudioInitialized){ initializeIOSAudio(); await new Promise(r=>setTimeout(r,100)); }
          attachAnalyserToMediaElement();
          const bin=Uint8Array.from(atob(b64.split(',')[1]), c=>c.charCodeAt(0));
          const blob=new Blob([bin], {type:'audio/mp3'});
          if(currentObjectURL){ URL.revokeObjectURL(currentObjectURL); currentObjectURL=null; }
          currentObjectURL=URL.createObjectURL(blob);
          if(!audioEl){
            audioEl=document.createElement('audio');
            audioEl.style.position='absolute'; audioEl.style.left='-9999px';
            audioEl.setAttribute('playsinline',''); audioEl.setAttribute('webkit-playsinline',''); document.body.appendChild(audioEl);
          }
          audioEl.src=currentObjectURL; audioEl.load();
          audioEl.onplay = ()=>{ setClosed(); startMouth(); tagPlaying=true; };
          audioEl.onended= ()=>{ tagPlaying=false; stopMouth(); if(currentObjectURL){ URL.revokeObjectURL(currentObjectURL); currentObjectURL=null; } onEnd&&onEnd(); };
          const pp=audioEl.play(); if(pp!==undefined) await pp; return;
        }catch(err){
          console.error('iOS audio playback failed', err);
          startMouth(); const approx=Math.min(7, Math.max(2.2, typed.textContent.length/16));
          setTimeout(()=>{ stopMouth(); onEnd&&onEnd(); }, (approx+0.2)*1000); return;
        }
      }
      try{
        ensureCtx(); ensureAnalyser();
        const bin=Uint8Array.from(atob(b64.split(',')[1]), c=>c.charCodeAt(0));
        const buf=await audioCtx.decodeAudioData(bin.buffer);
        currentSource=audioCtx.createBufferSource(); currentSource.buffer=buf; currentSource.playbackRate.value=1.08;
        attachAnalyserToBufferSource(currentSource);
        setClosed(); startMouth(); currentSource.start();
        currentSource.onended=()=>{ currentSource=null; stopMouth(); onEnd&&onEnd(); };
        return;
      }catch(e){
        console.warn('WebAudio decode failed', e);
      }
      try{
        ensureCtx(); ensureAnalyser(); attachAnalyserToMediaElement();
        const bin=Uint8Array.from(atob(b64.split(',')[1]), c=>c.charCodeAt(0));
        const blob=new Blob([bin], {type:'audio/mp3'});
        if(!audioEl){ audioEl=document.createElement('audio'); audioEl.hidden=true; document.body.appendChild(audioEl); }
        if(currentObjectURL){ URL.revokeObjectURL(currentObjectURL); currentObjectURL=null; }
        currentObjectURL=URL.createObjectURL(blob); audioEl.src=currentObjectURL;
        audioEl.onplay = ()=>{ setClosed(); startMouth(); tagPlaying=true; };
        audioEl.onended= ()=>{ tagPlaying=false; stopMouth(); if(currentObjectURL){ URL.revokeObjectURL(currentObjectURL); currentObjectURL=null; } onEnd&&onEnd(); };
        await audioEl.play();
      }catch(err){
        console.error('Plain <audio> failed', err);
        startMouth(); const approx=Math.min(7, Math.max(2.2, text.length/16));
        setTimeout(()=>{ stopMouth(); onEnd&&onEnd(); }, (approx+0.2)*1000);
      }
    }

    /* Freeze toggle (emoji) */
    function setFrozen(v){
      frozen = !!v;
      freezeEmoji.textContent = frozen ? '💫' : '❄️';
      freezeEmoji.setAttribute('title', frozen ? 'Unfreeze' : 'Freeze');
      if(frozen){ [...document.querySelectorAll('video,audio')].forEach(el=>{ try{el.pause();}catch(_){}}); }
      else { if(doorOpen && outputContainer.classList.contains('active')) setTimeout(()=>closeDoor(), 3000); }
    }
    freezeEmoji.addEventListener('click', (e)=>{ e.stopPropagation(); setFrozen(!frozen); });

    /* main */
    async function summon(){
      if(busy) return;
      try{ clickSnd.currentTime=0; clickSnd.play(); }catch(_){}
      busy=true; setFrozen(false); 
      // stop any old audio
      try{ if(window.currentSource) currentSource.stop(0); }catch(_){}
      try{ if(window.audioEl){ audioEl.pause(); audioEl.currentTime=0; } }catch(_){}

      // open & stage
      typed.textContent='';
      const oldTag=document.querySelector('#output .work-tag'); if(oldTag) oldTag.remove();
      openDoor();

      try{
        await new Promise(r=>setTimeout(r, DOOR_SWING_MS + EMERGE_MS + WADDLE_MS));
        const res = await fetch(ENDPOINT + QUERY, { cache:'no-store' });
        if(!res.ok) throw new Error('HTTP '+res.status);
        const data = await res.json();
        const work = data.work || null, author = data.author || null;
        const text = (data.text||'').trim().replace(/!+$/,''); // bubble handles period

        typeOut(text.endsWith('.')||text.endsWith('?')||text.endsWith('!') ? text : text+'.', async ()=>{
          const onEnd = ()=>{
            showWork(work, author);
            placeBubble();
            if(!frozen) setTimeout(()=>closeDoor(), 3000);
          };
          if(data.audioBase64){ await playAudio(data.audioBase64, onEnd); }
          else {
            // silent timing fallback
            const approx=Math.min(7, Math.max(2.2, text.length/16));
            setTimeout(onEnd, (approx+0.2)*1000);
          }
        });

      }catch(e){
        console.error(e);
        typeOut('A shy packet tripped. Try again.');
        setTimeout(()=>{ if(!frozen) closeDoor(); else busy=false; }, 2000);
      }
    }

    doorTrigger.addEventListener('click', summon);
    doorTrigger.addEventListener('keydown', e=>{ if(e.key===' '||e.key==='Enter'){ e.preventDefault(); summon(); } });

    /* Calibration (optional) */
    const calHud=document.getElementById('calHud'); let calOn=false, calTarget='door'; const STORAGE_KEY='cc_vars';
    function getVar(name,fallback){ const v=parseFloat(getComputedStyle(document.documentElement).getPropertyValue(name)); return isNaN(v)?(fallback??0):v; }
    function setVar(name,value){ document.documentElement.style.setProperty(name,String(value)); persistVars(); positionDoorAndChunklet(); updateHud(); }
    function persistVars(){
      const data={ door_x:getVar('--door-x'), door_y:getVar('--door-y'), door_w:getVar('--door-w'), door_h:getVar('--door-h'),
        mouth_top:getComputedStyle(document.documentElement).getPropertyValue('--mouth-top'),
        mouth_left:getComputedStyle(document.documentElement).getPropertyValue('--mouth-left') };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    }
    function loadVars(){
      try{
        const raw=localStorage.getItem(STORAGE_KEY); if(!raw) return;
        const d=JSON.parse(raw);
        if(d.door_x) document.documentElement.style.setProperty('--door-x', d.door_x);
        if(d.door_y) document.documentElement.style.setProperty('--door-y', d.door_y);
        if(d.door_w) document.documentElement.style.setProperty('--door-w', d.door_w);
        if(d.door_h) document.documentElement.style.setProperty('--door-h', d.door_h);
        if(d.mouth_top)  document.documentElement.style.setProperty('--mouth-top', d.mouth_top);
        if(d.mouth_left) document.documentElement.style.setProperty('--mouth-left', d.mouth_left);
      }catch(_){}
    }
    function updateHud(){
      if(!calOn) return;
      const door={ x:getVar('--door-x').toFixed(3), y:getVar('--door-y').toFixed(3), w:getVar('--door-w').toFixed(3), h:getVar('--door-h').toFixed(3) };
      const mTop=getComputedStyle(document.documentElement).getPropertyValue('--mouth-top').trim();
      const mLeft=getComputedStyle(document.documentElement).getPropertyValue('--mouth-left').trim();
      calHud.textContent=
`CALIBRATION (${calTarget.toUpperCase()})  —  Shift = fine
Door  x:${door.x}  y:${door.y}  w:${door.w}  h:${door.h}
Mouth top:${mTop}  left:${mLeft}
C=toggle  M=switch target  R=reset saved`;
    }
    function toggleCal(){ calOn=!calOn; calHud.classList.toggle('on', calOn); updateHud(); }
    function resetSaved(){ localStorage.removeItem(STORAGE_KEY); location.reload(); }
    loadVars();
    window.addEventListener('keydown', (e)=>{
      if(e.key==='c'||e.key==='C'){ toggleCal(); return; }
      if(!calOn) return;
      const fine=e.shiftKey, step=fine?0.001:0.003, pct=fine?0.5:1.0;
      if(e.key==='m'||e.key==='M'){ calTarget=calTarget==='door'?'mouth':'door'; updateHud(); return; }
      if(e.key==='r'||e.key==='R'){ resetSaved(); return; }
      if(calTarget==='door'){
        if(e.key==='ArrowLeft')  setVar('--door-x', getVar('--door-x')-step);
        if(e.key==='ArrowRight') setVar('--door-x', getVar('--door-x')+step);
        if(e.key==='ArrowUp')    setVar('--door-y', getVar('--door-y')-step);
        if(e.key==='ArrowDown')  setVar('--door-y', getVar('--door-y')+step);
        if(e.key==='[')          setVar('--door-w', Math.max(0.01, getVar('--door-w')-step));
        if(e.key===']')          setVar('--door-w', getVar('--door-w')+step);
        if(e.key==='{')          setVar('--door-h', Math.max(0.01, getVar('--door-h')-step));
        if(e.key==='}')          setVar('--door-h', getVar('--door-h')+step);
      }else{
        const top=parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--mouth-top'));
        const left=parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--mouth-left'));
        if(e.key==='ArrowUp')    { document.documentElement.style.setProperty('--mouth-top', (top - pct)+'%'); persistVars(); positionDoorAndChunklet(); updateHud(); }
        if(e.key==='ArrowDown')  { document.documentElement.style.setProperty('--mouth-top', (top + pct)+'%'); persistVars(); positionDoorAndChunklet(); updateHud(); }
        if(e.key==='ArrowLeft')  { document.documentElement.style.setProperty('--mouth-left',(left- pct)+'%'); persistVars(); positionDoorAndChunklet(); updateHud(); }
        if(e.key==='ArrowRight') { document.documentElement.style.setProperty('--mouth-left',(left+ pct)+'%'); persistVars(); positionDoorAndChunklet(); updateHud(); }
      }
    });

    // initial layout
    (function boot(){
      positionDoorAndChunklet();
      if(bgImg.complete) placeBubble(); else bgImg.addEventListener('load', placeBubble);
    })();
  </script>
</body>
</html>
