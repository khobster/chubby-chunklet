<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>chubby chunklet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <!-- Icons -->
  <link rel="icon" type="image/png" href="favicon.png" />
  <link rel="apple-touch-icon" href="favicon.png" />

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;700&family=Inter:wght@600;700&family=VT323&family=Bebas+Neue&display=swap" rel="stylesheet" />

  <style>
    :root{
      /* Backend */
      --endpoint: https://pu30nzsu59.execute-api.us-east-1.amazonaws.com/dev/chunklet;

      /* Chunklet sprite / mouth */
      --figure-scale:1.15;
      --mouth-top:42%;
      --mouth-left:50%;
      --mouth-w:20px;
      --mouth-h:20px;
      --mouth-scale-0:.05;

      /* Typing */
      --char-ms:18;

      /* Colors / fonts */
      --terminal-color:#FFFFFF;
      --jeopardy-blue:#0033CC;
      --font-mono:'IBM Plex Mono',ui-monospace,Menlo,Consolas,monospace;
      --font-phrase:'Bebas Neue','Impact',sans-serif;

      /* Door anchor on the background image (fractions 0..1 and size vs image width/height) */
      --door-x: 0.503;   /* center x */
      --door-y: 0.560;   /* center y */
      --door-w: 0.095;   /* width */
      --door-h: 0.255;   /* height */

      /* Default placement of the blue card (bumped up if it overlaps Chunklet) */
      --output-top-fallback: 8vmin;
    }

    /* ---------- layout ---------- */
    *{box-sizing:border-box}
    html,body{
      margin:0;padding:0;
      font-family:Inter,system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto;
      background:#000;
      color:#fff;
      -webkit-font-smoothing:antialiased;
      overflow:hidden;
      height:100%;
      width:100%;
    }

    /* Scene background - full screen */
    .scene-container{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background:#4a7ba7; /* Sky blue fallback */
    }
    .scene-bg{
      width:100%;
      height:100%;
      position:relative;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .scene-bg img{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
      user-select:none;
      -webkit-user-drag:none;
    }

    /* Door (positioned by JS from the normalized vars) */
    .door-container{
      position:absolute;
      transform:translate(-50%, -50%);
      cursor:pointer;
      z-index:50; /* above background, below Chunklet */
    }
    /* Brown doors that match the art style */
    .door-left, .door-right{
      position:absolute;
      width:50%;
      height:100%;
      background:#3d2418;
      border:3px solid #2d1810;
      transition:transform 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      box-shadow:
        inset 0 0 20px rgba(0,0,0,0.4),
        0 0 10px rgba(0,0,0,0.8);
      backface-visibility:hidden;
      transform-style:preserve-3d;
    }
    .door-left{
      left:0;
      transform-origin:left center;
      border-right:2px solid #1a0e08;
    }
    .door-right{
      right:0;
      transform-origin:right center;
      border-left:2px solid #1a0e08;
    }
    /* Door panels */
    .door-panel{
      position:absolute;
      background:#2d1810;
      border:2px solid #1a0e08;
      box-shadow:
        inset 2px 2px 4px rgba(0,0,0,0.4),
        inset -1px -1px 2px rgba(61,36,24,0.3);
    }
    .door-left .panel-top{   width:65%; height:22%; top:15%; left:17.5%;}
    .door-left .panel-mid{   width:65%; height:22%; top:41%; left:17.5%;}
    .door-left .panel-bottom{width:65%; height:22%; top:67%; left:17.5%;}
    .door-right .panel-top{   width:65%; height:22%; top:15%; right:17.5%;}
    .door-right .panel-mid{   width:65%; height:22%; top:41%; right:17.5%;}
    .door-right .panel-bottom{width:65%; height:22%; top:67%; right:17.5%;}

    /* Open state */
    .door-open .door-left{transform:rotateY(85deg);}
    .door-open .door-right{transform:rotateY(-85deg);}

    /* Chunklet character */
    .chunklet-container{
      position:absolute;
      transform:translate(-50%, -30px);
      opacity:0;
      transition:opacity 0.3s;
      z-index:60;   /* always in front of the blue card */
      pointer-events:none;
    }
    .chunklet-container.active{ opacity:1; }

    /* Bouncy trot animation */
    @keyframes bouncyTrot {
      0% { transform:translate(-50%, -30px) }
      5% { transform:translate(-50%, -25px) rotate(-2deg) }
      10% { transform:translate(-50%, -20px) }
      15% { transform:translate(-50%, -15px) rotate(2deg) }
      20% { transform:translate(-50%, -10px) }
      25% { transform:translate(-50%, -5px) rotate(-2deg) }
      30% { transform:translate(-50%, 0px) }
      35% { transform:translate(-50%, 5px) rotate(2deg) }
      40% { transform:translate(-50%, 10px) }
      45% { transform:translate(-50%, 15px) rotate(-2deg) }
      50% { transform:translate(-50%, 20px) }
      55% { transform:translate(-50%, 25px) rotate(2deg) }
      60% { transform:translate(-50%, 30px) }
      65% { transform:translate(-50%, 35px) rotate(-2deg) }
      70% { transform:translate(-50%, 40px) }
      75% { transform:translate(-50%, 45px) rotate(2deg) }
      80% { transform:translate(-50%, 50px) }
      85% { transform:translate(-50%, 55px) rotate(-1deg) }
      90% { transform:translate(-50%, 60px) }
      95% { transform:translate(-50%, 65px) }
      100%{ transform:translate(-50%, 70px) }
    }
    .chunklet-container.trotting{ animation:bouncyTrot 1.5s ease-out forwards; }

    .chunklet-wrap{
      position:relative;
      width:calc(100px*var(--figure-scale));
      height:calc(130px*var(--figure-scale));
      display:flex;
      align-items:flex-end;
      justify-content:center;
    }
    .chunklet-img{
      width:calc(90px*var(--figure-scale));
      max-width:100%;
      user-select:none;
      -webkit-user-drag:none;
      filter:drop-shadow(0 8px 16px rgba(0,0,0,.6));
      image-rendering:-webkit-optimize-contrast;
    }

    /* Mouth overlay - positioned over the face */
    .mouth-overlay{
      position:absolute;
      top:var(--mouth-top);
      left:var(--mouth-left);
      width:var(--mouth-w);
      height:var(--mouth-h);
      transform:translate(-50%,-50%);
      display:flex;
      align-items:center;
      justify-content:center;
      pointer-events:none;
    }
    .mouth-overlay svg{width:100%;height:100%}
    #mouth{transform-origin:50% 50%; transform:scale(1, var(--mouth-scale-0))}

    /* Jeopardy-style blue screen container */
    .output-container{
      position:fixed;
      left:50%;
      transform:translateX(-50%);
      width:85%;
      max-width:850px;
      z-index:40;               /* under the star */
      opacity:0;
      transition:opacity 0.5s;
      pointer-events:none;
      top:var(--output-top-fallback);
    }
    .output-container.active{ opacity:1; }

    /* Jeopardy blue screen */
    .jeopardy-screen{
      background:var(--jeopardy-blue);
      border:10px solid #001a66;
      border-radius:0;
      padding:25px 35px;
      box-shadow:
        inset 0 0 30px rgba(0,0,0,0.4),
        0 10px 40px rgba(0,0,0,0.9),
        0 0 80px rgba(0,51,204,0.4);
      position:relative;
      overflow:hidden;
    }
    /* TV scan lines effect */
    .jeopardy-screen::before{
      content:'';
      position:absolute; inset:0;
      background:repeating-linear-gradient(
        0deg,
        transparent 0px,
        transparent 2px,
        rgba(0,0,0,0.08) 2px,
        rgba(0,0,0,0.08) 4px
      );
      pointer-events:none;
    }

    /* Jeopardy style text */
    .output{
      font-family:var(--font-phrase);
      text-transform:uppercase;
      font-size:clamp(22px, 3vw, 36px);
      line-height:1.35;
      letter-spacing:.15em;
      font-weight:400;
      color:var(--terminal-color);
      text-align:center;
      margin:0;
      white-space:pre-wrap;
      position:relative;
      text-shadow:
        3px 3px 0 #000,
        4px 4px 0 #000,
        5px 5px 0 #000,
        6px 6px 12px rgba(0,0,0,0.9),
        0 0 30px rgba(255,255,255,0.3);
      z-index:1;
    }
    .cursor{
      display:inline-block;
      width:.7ch;
      height:1.2em;
      background:var(--terminal-color);
      vertical-align:text-bottom;
      animation:blink 1s steps(1,end) infinite;
      box-shadow:
        3px 3px 0 #000,
        0 0 10px rgba(255,255,255,0.8);
    }
    @keyframes blink{0%,55%{opacity:1}56%,100%{opacity:0}}
    .typing .cursor{animation:none}

    .output .work-tag{
      opacity:.9;
      font-family: var(--font-phrase);
      text-transform: uppercase;
      font-style: normal;
      margin-left:.6em;
      font-size:.65em;
      letter-spacing:.1em;
      font-weight: 400;
      color:#FFFFFF;
      display:block;
      margin-top:12px;
      text-shadow:
        2px 2px 0 #000,
        3px 3px 0 #000,
        4px 4px 8px rgba(0,0,0,0.8);
    }

    /* Mobile adjustments */
    @media(max-width:600px){
      .output-container{ width:92%; }
      .jeopardy-screen{ padding:18px 25px; border-width:6px; }
      .output{ font-size:clamp(16px, 4vw, 24px); }
    }
  </style>
</head>
<body>
  <!-- Click SFX (optional) -->
  <audio id="clickSnd" src="click.mp3" preload="auto"></audio>

  <div class="scene-container">
    <div class="scene-bg">
      <img src="skullbones.png" alt="Scene background" />

      <!-- Interactive door -->
      <div class="door-container" id="doorTrigger" aria-label="Open the door" role="button" tabindex="0">
        <div class="door-left">
          <div class="door-panel panel-top"></div>
          <div class="door-panel panel-mid"></div>
          <div class="door-panel panel-bottom"></div>
        </div>
        <div class="door-right">
          <div class="door-panel panel-top"></div>
          <div class="door-panel panel-mid"></div>
          <div class="door-panel panel-bottom"></div>
        </div>
      </div>

      <!-- Chunklet character -->
      <div class="chunklet-container" id="chunkletContainer" aria-hidden="true">
        <div class="chunklet-wrap">
          <img src="littleboytalk.png" alt="Chubby Chunklet" class="chunklet-img" />
          <div class="mouth-overlay">
            <svg viewBox="0 0 100 100" aria-hidden="true">
              <ellipse id="mouth" cx="50" cy="50" rx="26" ry="24" fill="#111"/>
            </svg>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Jeopardy-style phrase output -->
  <div class="output-container" id="outputContainer" aria-live="polite">
    <div class="jeopardy-screen">
      <div class="output" id="output">
        <span id="typed"></span><span id="cursor" class="cursor"></span>
      </div>
    </div>
  </div>

  <script>
    /* ===== CONFIG ===== */
    const css = getComputedStyle(document.documentElement);
    const ENDPOINT = (css.getPropertyValue('--endpoint') || '').trim() ||
      'https://pu30nzsu59.execute-api.us-east-1.amazonaws.com/dev/chunklet';
    const QUERY    = '?style=canon&modern=0&accent=scottish';
    const CHAR_MS  = parseInt(css.getPropertyValue('--char-ms'),10) || 20;

    const doorTrigger       = document.getElementById('doorTrigger');
    const chunkletContainer = document.getElementById('chunkletContainer');
    const outputContainer   = document.getElementById('outputContainer');
    const typed             = document.getElementById('typed');
    const cursor            = document.getElementById('cursor');
    const mouth             = document.getElementById('mouth');
    const output            = document.getElementById('output');
    const clickSnd          = document.getElementById('clickSnd');

    const bgImg   = document.querySelector('.scene-bg img');
    const host    = document.querySelector('.scene-bg');
    const isIOS   = /iP(hone|od|ad)|Macintosh.*Mobile/.test(navigator.userAgent);

    /* ---------- state ---------- */
    let busy=false;
    let doorOpen=false;
    let audioCtx,currentSource,audioEl,mediaSource,analyser,timeData;
    let raf,animating=false,tagPlaying=false;
    let currentObjectURL=null;
    let iosAudioInitialized = false;

    /* ===== multi-level fast flap (discrete bands with hysteresis) ===== */
    const SY = [0.07, 0.55, 1.10, 1.70, 2.30];
    const SX = [1.00, 1.01, 1.02, 1.02, 1.03];
    const THRESH_UP   = [0.030, 0.060, 0.100, 0.160];
    const HYST_DELTA  = 0.018;
    const THRESH_DOWN = THRESH_UP.map(t => Math.max(0, t - HYST_DELTA));
    const GATE_FLOOR  = 0.010;
    const CLOSE_GRACE_MS = 20;

    let level = 0;
    let lastChange = 0;

    /* ===== Audio plumbing ===== */
    function ensureCtx(){
      if(!audioCtx) audioCtx = new (window.AudioContext||window.webkitAudioContext)();
      if(audioCtx.state === 'suspended') audioCtx.resume();
    }
    function ensureAnalyser(){
      ensureCtx();
      if(!analyser){
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 256;
        analyser.smoothingTimeConstant = 0.0;
        timeData = new Float32Array(analyser.fftSize);
      }
    }
    function attachAnalyserToBufferSource(srcNode){
      ensureAnalyser();
      try{ srcNode.disconnect(); }catch(_){}
      srcNode.connect(analyser);
      analyser.connect(audioCtx.destination);
    }
    function attachAnalyserToMediaElement(){
      ensureAnalyser();
      if(isIOS && !iosAudioInitialized){
        initializeIOSAudio();
        return;
      }
      if(!audioEl){
        audioEl = document.createElement('audio');
        audioEl.style.position = 'absolute';
        audioEl.style.left = '-9999px';
        audioEl.setAttribute('playsinline', '');
        audioEl.setAttribute('webkit-playsinline', '');
        document.body.appendChild(audioEl);
      }
      if(!mediaSource && audioCtx && audioEl){
        try{
          mediaSource = audioCtx.createMediaElementSource(audioEl);
          mediaSource.connect(analyser);
          analyser.connect(audioCtx.destination);
        }catch(e){
          console.warn('createMediaElementSource failed', e);
        }
      }
    }
    function rmsLevel(){
      if(!analyser || !timeData) return 0;
      analyser.getFloatTimeDomainData(timeData);
      let sum = 0;
      for(let i=0;i<timeData.length;i++){
        const v = timeData[i];
        sum += v*v;
      }
      let rms = Math.sqrt(sum / timeData.length);
      if (rms < GATE_FLOOR) rms = 0;
      return rms;
    }

    /* ===== Mouth animation ===== */
    function setLevel(n){
      n = Math.max(0, Math.min(4, n|0));
      if (n === level) return;
      level = n;
      mouth.style.transform = `scale(${SX[level]}, ${SY[level]})`;
      lastChange = performance.now();
    }
    function setClosed(){ setLevel(0); }
    function startMouth(){
      if(animating) return;
      animating = true;
      raf = requestAnimationFrame(tick);
    }
    function stopMouth(){
      animating = false;
      cancelAnimationFrame(raf);
      setClosed();
    }
    function tick(){
      if(!animating) return;
      raf = requestAnimationFrame(tick);

      const active = !!currentSource || tagPlaying;
      const now = performance.now();

      if(active){
        if(analyser && (currentSource || (tagPlaying && mediaSource))){
          const e = rmsLevel();

          if(isIOS && e === 0 && tagPlaying){
            const t = (now/1000);
            const phase = ((t*15)|0) % 5;
            const levels = [1, 2, 3, 2, 1];
            setLevel(levels[phase]);
            return;
          }

          let target = level;
          while (target < 4 && e >= THRESH_UP[target]) target++;
          while (target > 0 && e < THRESH_DOWN[target-1]) target--;

          if (target < level && (now - lastChange) < CLOSE_GRACE_MS) {
            target = level;
          }
          setLevel(target);
        }else{
          const t = (now/1000);
          const phase = ((t*15)|0) % 5;
          const levels = [1, 2, 3, 2, 1];
          setLevel(levels[phase]);
        }
        return;
      }

      const t = (now/1000);
      const phase = ((t*13)|0) % 4;
      const rand = Math.random();
      const target = phase === 0 ? 0
                    : phase === 1 ? (rand < .7 ? 1 : 2)
                    : phase === 2 ? (rand < .6 ? 2 : 3)
                    :               (rand < .5 ? 3 : 4);
      setLevel(target);
    }

    /* ===== iOS unlock ===== */
    function initializeIOSAudio(){
      if(iosAudioInitialized) return;
      try{
        ensureCtx();
        if(!audioEl){
          audioEl = document.createElement('audio');
          audioEl.style.position = 'absolute';
          audioEl.style.left = '-9999px';
          audioEl.setAttribute('playsinline', '');
          audioEl.setAttribute('webkit-playsinline', '');
          document.body.appendChild(audioEl);
        }
        const silentMP3 = 'data:audio/mp3;base64,SUQzBAAAAAAAI1RTU0UAAAAPAAADTGF2ZjU4LjQ1LjEwMAAAAAAAAAAAAAAA//tQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAACAAABhgC7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u////////////////////////////////////////////////////////AAAAAExhdmY1OC40NS4xMDAAAAAAAAAAAAAAAAAAAAAkAAAAAAAAAAAAYYZn5GDeAAAAAAD/+1DEAAAAAAAAAAAAAAAAAAAAAAAASW5mbwAAAA8AAAACAAABhgC7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u7u////////////////////////////////////////////////////////AAAAAExhdmY1OC40NS4xMDAAAAAAAAAAAAAAAAAAAAAkAAAAAAAAAAABhmfkYN4AAAAAAP/7UMQAA8AAAGkAAAAIAAANIAAAARMQU1AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA';
        audioEl.src = silentMP3;
        audioEl.load();
        const playPromise = audioEl.play();
        if(playPromise !== undefined){
          playPromise.then(() => {
            audioEl.pause();
            audioEl.currentTime = 0;
            if(!mediaSource && audioCtx){
              try{
                mediaSource = audioCtx.createMediaElementSource(audioEl);
                ensureAnalyser();
                mediaSource.connect(analyser);
                analyser.connect(audioCtx.destination);
                iosAudioInitialized = true;
              }catch(e){
                console.warn('iOS audio init partial success, no analyser:', e);
              }
            }
          }).catch(e => {
            console.warn('iOS audio init failed:', e);
          });
        }
      }catch(e){
        console.warn('iOS audio initialization error:', e);
      }
    }
    function unlockAudioOnce(){
      try{
        ensureCtx();
        if(isIOS){
          initializeIOSAudio();
        } else {
          const buf = audioCtx.createBuffer(1,1,22050);
          const src = audioCtx.createBufferSource();
          src.buffer = buf; src.connect(audioCtx.destination); src.start(0);
        }
      }catch(_){}
      document.removeEventListener('touchstart', unlockAudioOnce);
      document.removeEventListener('click', unlockAudioOnce);
    }
    document.addEventListener('touchstart', unlockAudioOnce, {once:true, passive:true});
    document.addEventListener('click', unlockAudioOnce, {once:true});

    /* ===== helpers ===== */
    const sanitize = txt=>{
      txt=(txt||'').trim().replace(/!+$/,'').replace(/\s+/g,' ');
      return /[.?!]$/.test(txt)?txt:txt+'.';
    };
    function typeOut(text, done){
      typed.textContent='';
      output.classList.add('typing');
      (function loop(i=0){
        typed.textContent = text.slice(0,i);
        if(i<text.length){
          setTimeout(()=>loop(i+1), CHAR_MS + ((i%7)?0:Math.random()*10));
        }else{
          output.classList.remove('typing');
          done && done();
        }
      })();
    }
    function stopAudio(){
      if(currentSource){
        try{ currentSource.stop(); }catch(_){}
        try{ currentSource.disconnect(); }catch(_){}
        currentSource = null;
      }
      if(audioEl){
        try{ audioEl.pause(); audioEl.currentTime = 0; }catch(_){}
      }
      if(currentObjectURL){
        URL.revokeObjectURL(currentObjectURL);
        currentObjectURL = null;
      }
      tagPlaying = false;
    }
    function showWork(work, author){
      const old = output.querySelector('.work-tag');
      if(old) old.remove();
      if(!work && !author) return;
      const span = document.createElement('span');
      span.className = 'work-tag';
      span.textContent = '— ' + [work, author].filter(Boolean).join(' · ');
      output.appendChild(span);
    }

    /* ===== Door + Chunklet positioning (normalized to background image) ===== */
    const DOOR = {
      get x(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--door-x')) || 0.5; },
      get y(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--door-y')) || 0.55; },
      get w(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--door-w')) || 0.10; },
      get h(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--door-h')) || 0.25; }
    };

    function positionDoorAndChunklet(){
      if(!bgImg.naturalWidth || !host) return;

      const hostRect = host.getBoundingClientRect();
      const natW = bgImg.naturalWidth, natH = bgImg.naturalHeight;

      // object-fit: cover math
      const scale = Math.max(hostRect.width / natW, hostRect.height / natH);
      const dispW = natW * scale;
      const dispH = natH * scale;
      const offsetX = (hostRect.width  - dispW) / 2;
      const offsetY = (hostRect.height - dispH) / 2;

      // Center of door in VIEWPORT pixels
      const cx = hostRect.left + offsetX + dispW * DOOR.x;
      const cy = hostRect.top  + offsetY + dispH * DOOR.y;

      const dw = dispW * DOOR.w;
      const dh = dispH * DOOR.h;

      // Apply relative to host (.scene-bg) by subtracting host origin
      Object.assign(doorTrigger.style, {
        left:  (cx - hostRect.left) + 'px',
        top:   (cy - hostRect.top)  + 'px',
        width: dw + 'px',
        height:dh + 'px'
      });

      // Place chunklet slightly below the door center
      const exitY = cy + dh * 0.35;
      Object.assign(chunkletContainer.style, {
        left: (cx - hostRect.left) + 'px',
        top:  (exitY - hostRect.top) + 'px',
        transform: 'translate(-50%, -30px)'
      });

      avoidOverlap();
    }

    function avoidOverlap(){
      // reset to fallback
      outputContainer.style.top = getComputedStyle(document.documentElement)
        .getPropertyValue('--output-top-fallback');

      const cardRect = outputContainer.getBoundingClientRect();
      const guyRect  = chunkletContainer.getBoundingClientRect();

      const overlap = !(cardRect.bottom < guyRect.top || cardRect.top > guyRect.bottom ||
                        cardRect.right < guyRect.left || cardRect.left > guyRect.right);

      if(overlap){
        const idealTop = Math.max(8, Math.round(guyRect.top - cardRect.height - 24));
        outputContainer.style.top = idealTop + 'px';
      }
    }

    function onReadyToPosition(){
      positionDoorAndChunklet();
      setTimeout(positionDoorAndChunklet, 50);
      setTimeout(positionDoorAndChunklet, 250);
    }
    if(bgImg.complete) onReadyToPosition();
    else bgImg.addEventListener('load', onReadyToPosition);
    window.addEventListener('resize', positionDoorAndChunklet);
    window.addEventListener('orientationchange', positionDoorAndChunklet);

    /* ===== Door choreography ===== */
    function openDoor(){
      if(doorOpen) return;
      positionDoorAndChunklet();  // ensure alignment first
      doorOpen = true;
      doorTrigger.classList.add('door-open');

      setTimeout(() => {
        chunkletContainer.classList.add('active','trotting');
        setTimeout(() => {
          outputContainer.classList.add('active');
          avoidOverlap();          // keep the card off the star
        }, 1500);
      }, 800);
    }
    function closeDoor(){
      if(!doorOpen) return;
      doorOpen = false;
      chunkletContainer.classList.remove('active', 'trotting');
      outputContainer.classList.remove('active');
      setTimeout(() => {
        doorTrigger.classList.remove('door-open');
        busy = false;
      }, 500);
    }

    /* ===== playback ===== */
    async function playAudio(b64,onEnd){
      if(isIOS){
        try{
          ensureCtx();
          if(!iosAudioInitialized){
            initializeIOSAudio();
            await new Promise(r => setTimeout(r, 100));
          }
          attachAnalyserToMediaElement();

          const bin  = Uint8Array.from(atob(b64.split(',')[1]), c=>c.charCodeAt(0));
          const blob = new Blob([bin], {type:'audio/mp3'});

          if(currentObjectURL){ URL.revokeObjectURL(currentObjectURL); currentObjectURL=null; }
          currentObjectURL = URL.createObjectURL(blob);

          if(!audioEl){
            audioEl = document.createElement('audio');
            audioEl.style.position = 'absolute';
            audioEl.style.left = '-9999px';
            audioEl.setAttribute('playsinline', '');
            audioEl.setAttribute('webkit-playsinline', '');
            document.body.appendChild(audioEl);
          }

          audioEl.src = currentObjectURL;
          audioEl.load();

          audioEl.onplay  = ()=>{ setClosed(); startMouth(); tagPlaying=true; };
          audioEl.onended = ()=>{
            tagPlaying=false; stopMouth();
            if(currentObjectURL){ URL.revokeObjectURL(currentObjectURL); currentObjectURL=null; }
            onEnd && onEnd();
          };

          const pp = audioEl.play();
          if(pp !== undefined) await pp;
          return;
        }catch(err){
          console.error('iOS audio playback failed', err);
          startMouth();
          const approx = Math.min(7, Math.max(2.2, typed.textContent.length/16));
          setTimeout(()=>{ stopMouth(); onEnd && onEnd(); }, (approx+0.2)*1000);
          return;
        }
      }

      try{
        ensureCtx(); ensureAnalyser();
        const bin = Uint8Array.from(atob(b64.split(',')[1]), c=>c.charCodeAt(0));
        const buf = await audioCtx.decodeAudioData(bin.buffer);
        currentSource = audioCtx.createBufferSource();
        currentSource.buffer = buf;
        currentSource.playbackRate.value = 1.08;
        attachAnalyserToBufferSource(currentSource);
        setClosed(); startMouth();
        currentSource.start();
        currentSource.onended = ()=>{
          currentSource=null; stopMouth(); onEnd && onEnd();
        };
        return;
      }catch(e){
        console.warn('WebAudio decode failed, fallback to <audio>', e);
      }

      try{
        ensureCtx(); ensureAnalyser(); attachAnalyserToMediaElement();
        const bin  = Uint8Array.from(atob(b64.split(',')[1]), c=>c.charCodeAt(0));
        const blob = new Blob([bin], {type:'audio/mp3'});

        if(!audioEl){
          audioEl = document.createElement('audio');
          audioEl.hidden = true;
          document.body.appendChild(audioEl);
        }
        if(currentObjectURL){ URL.revokeObjectURL(currentObjectURL); currentObjectURL=null; }
        currentObjectURL = URL.createObjectURL(blob);
        audioEl.src = currentObjectURL;

        audioEl.onplay  = ()=>{ setClosed(); startMouth(); tagPlaying=true; };
        audioEl.onended = ()=>{
          tagPlaying=false; stopMouth();
          if(currentObjectURL){ URL.revokeObjectURL(currentObjectURL); currentObjectURL=null; }
          onEnd && onEnd();
        };
        await audioEl.play();
      }catch(err){
        console.error('Plain <audio> failed', err);
        startMouth();
        const approx = Math.min(7, Math.max(2.2, typed.textContent.length/16));
        setTimeout(()=>{ stopMouth(); onEnd && onEnd(); }, (approx+0.2)*1000);
      }
    }

    /* ===== main ===== */
    async function summon(){
      if(busy) return;

      try{ clickSnd.currentTime = 0; clickSnd.play(); }catch(_){}
      busy = true;
      stopAudio();

      openDoor();

      // Clear previous text/tag
      typed.textContent='';
      const oldTag = output.querySelector('.work-tag');
      if(oldTag) oldTag.remove();

      try{
        // Wait for door + trot
        await new Promise(resolve => setTimeout(resolve, 2300));

        const res = await fetch(ENDPOINT + QUERY, { cache:'no-store' });
        if(!res.ok) throw new Error('HTTP '+res.status);
        const data = await res.json();
        const work = data.work || null;
        const author = data.author || null;
        const text = sanitize(data.text);

        typeOut(text, async ()=>{
          const onEnd = ()=>{
            showWork(work, author);
            avoidOverlap(); // final check after text height is known
            setTimeout(() => { closeDoor(); }, 3000);
          };

          if(data.audioBase64){
            await playAudio(data.audioBase64, onEnd);
          }else{
            startMouth();
            const approx = Math.min(7, Math.max(2.2, text.length/16));
            setTimeout(()=>{ stopMouth(); onEnd(); }, (approx+0.2)*1000);
          }
        });

      }catch(e){
        console.error(e);
        typeOut('A shy packet tripped. Try again.');
        setTimeout(() => { closeDoor(); }, 2000);
      }
    }

    // Interactions
    doorTrigger.addEventListener('click', summon);
    doorTrigger.addEventListener('keydown', (e)=>{
      if(e.key===' '||e.key==='Enter'){ e.preventDefault(); summon(); }
    });
  </script>
</body>
</html>
