<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Chubby Chunklet</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;700&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
<style>
:root {
  --text-color:#111;          /* Change to #1034a6 for “royal” blue text */
  --accent:#222;
  --key-top:#d9dadc;
  --key-side:#b4b6bb;
  --key-shadow:#6a6d73;
  --key-pressed-shift:6px;
  --mono:'IBM Plex Mono', ui-monospace, SFMono-Regular, Menlo, monospace;
  --talk-speed:26; /* ms per char */
}
* { box-sizing:border-box; }
html,body {
  margin:0;
  font-family:Inter, system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen;
  color:var(--text-color);
  background:#fff;
  -webkit-font-smoothing:antialiased;
}
body {
  display:flex;
  flex-direction:column;
  align-items:center;
  padding:48px 16px 120px;
}
h1 {
  margin:0 0 48px;
  font-size:20px;
  font-weight:600;
  letter-spacing:.5px;
}
h1 span { font-weight:700; }
.stage {
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:68px;
}
.chunklet-wrap {
  position:relative;
  width:190px;
  height:240px;
  display:flex;
  align-items:flex-end;
  justify-content:center;
}
.chunklet-photo {
  max-width:160px;
  width:160px;
  user-select:none;
  -webkit-user-drag:none;
  filter:drop-shadow(0 8px 18px rgba(0,0,0,.18));
}
.mouth-overlay {
  position:absolute;
  left:50%;
  top:106px; /* tune to match mouth position in photo */
  width:42px;
  height:42px;
  transform:translate(-50%,-50%);
  display:flex;
  align-items:center;
  justify-content:center;
  pointer-events:none;
}
.mouth-overlay svg {
  width:100%; height:100%;
}
#mouthShape {
  transform-origin:50% 50%;
  transition:transform .08s linear;
}
/* Key button */
.key-button {
  position:relative;
  width:120px;
  height:120px;
  cursor:pointer;
  border:none;
  background:transparent;
  padding:0;
  outline:none;
  -webkit-tap-highlight-color:transparent;
}
.keycap {
  position:absolute;
  left:50%; top:0;
  transform:translate(-50%,0);
  width:94px;
  height:94px;
  background:var(--key-top);
  border-radius:10px;
  border:2px solid #c6c8cc;
  box-shadow:0 6px 0 var(--key-side),
             0 10px 14px rgba(0,0,0,.28);
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:42px;
  font-weight:600;
  font-family:var(--mono);
  color:#383b40;
  letter-spacing:1px;
  transition:transform .12s cubic-bezier(.33,.9,.3,1), box-shadow .12s, filter .2s;
}
.keycap:before {
  content:"";
  position:absolute;
  inset:0;
  border-radius:inherit;
  background:
    linear-gradient(145deg,rgba(255,255,255,.85),rgba(255,255,255,0)),
    linear-gradient( to bottom, rgba(0,0,0,.05), rgba(0,0,0,0) 55%);
  mix-blend-mode:overlay;
  pointer-events:none;
}
.key-button:active .keycap,
.key-button.pressed .keycap {
  transform:translate(-50%,var(--key-pressed-shift));
  box-shadow:0 2px 0 var(--key-side),
             0 4px 10px rgba(0,0,0,.25);
}
.key-button:focus-visible .keycap {
  outline:4px solid #5b8dff;
  outline-offset:4px;
}
/* Terminal line */
.output {
  font-family:var(--mono);
  font-size:28px;
  line-height:1.35;
  font-weight:500;
  letter-spacing:.5px;
  white-space:pre-wrap;
  max-width:820px;
  min-height:3ch;
  margin-top:64px;
  position:relative;
}
.cursor {
  display:inline-block;
  width:.65ch;
  background:var(--text-color);
  animation:blink 1.05s steps(1) infinite;
  vertical-align:baseline;
  height:1em;
  transform:translateY(2px);
}
.typing .cursor { animation:none; }
@keyframes blink { 0%,55% {opacity:1;} 56%,100% {opacity:0;} }
.status {
  margin-top:20px;
  font-size:14px;
  opacity:.55;
}
.status.error { color:#c0392b; opacity:1; }
.notice {
  margin-top:40px;
  font-size:12px;
  opacity:.45;
  max-width:600px;
  text-align:center;
}
.hidden { display:none; }
.fade-in { animation:fade .5s ease; }
@keyframes fade { from{opacity:0; transform:translateY(6px);} to{opacity:1; transform:translateY(0);} }
.talking #mouthShape {
  animation:idleMouth .9s ease-in-out infinite;
}
@keyframes idleMouth {
  0%,100% {transform:scaleY(.6);}
  50% {transform:scaleY(.85);}
}
</style>
</head>
<body>
  <h1>oh wow hey it's <span>chubby chunklet</span></h1>

  <div class="stage">
    <div class="chunklet-wrap">
      <!-- Your actual image file; adjust src to your asset path -->
      <img id="chunkletImg" class="chunklet-photo" src="littlemantalk.png" alt="Chubby Chunklet">
      <!-- Mouth overlay (animated oval) -->
      <div class="mouth-overlay">
        <svg viewBox="0 0 100 100">
          <ellipse id="mouthShape" cx="50" cy="50" rx="26" ry="20" fill="#111"/>
        </svg>
      </div>
    </div>

    <button id="trigger" class="key-button" aria-label="Summon Chunklet">
      <div class="keycap">*</div>
    </button>
  </div>

  <div id="out" class="output"><span id="line"></span><span id="cursor" class="cursor"></span></div>
  <div id="status" class="status"></div>
  <div class="notice">Press the key. Chunklet speaks. Text typed retro style. Audio + mouth sync if available.</div>

<script>
const ENDPOINT = 'https://pu30nzsu59.execute-api.us-east-1.amazonaws.com/dev/chunklet'; // update if redeployed

const trigger   = document.getElementById('trigger');
const keycap    = trigger.querySelector('.keycap');
const lineSpan  = document.getElementById('line');
const cursorSpan= document.getElementById('cursor');
const statusEl  = document.getElementById('status');
const mouth     = document.getElementById('mouthShape');

let typing = false;
let audioCtx;
let currentSource;
let timings = [];
let startTime = 0;
let raf;
let lastText = '';
let busy = false;

/* Utility */
function setStatus(msg, isErr=false){
  statusEl.textContent = msg || '';
  statusEl.classList.toggle('error', !!isErr);
}
function sanitize(text){
  text = (text||'').trim();
  if(!text) return 'Ambient dust performs a silent tap routine.';
  return text.replace(/!+$/,'').replace(/\s+/g,' ').trim() + (/[.?!]$/.test(text)?'':'.');
}

/* Fetch + type sequence */
async function summon(){
  if(busy) return;
  busy = true;
  trigger.classList.add('pressed');
  setStatus('Chunklet thinking...');
  stopAudio();
  stopMouth();
  lineSpan.textContent = '';
  cursorSpan.classList.remove('hidden');
  document.getElementById('out').classList.remove('fade-in');

  try{
    const res = await fetch(ENDPOINT);
    if(!res.ok) throw new Error('Server '+res.status);
    const data = await res.json();
    let text = sanitize(data.text);
    lastText = text;
    timings = Array.isArray(data.timings) ? data.timings : [];
    typeLine(text, async () => {
      if(data.audioBase64){
        await playAudio(data.audioBase64);
      } else {
        fakeTimingsFromText(text);
        startMouth();
        setTimeout(stopMouth, 2500);
      }
      setStatus('Ready.');
      document.getElementById('out').classList.add('fade-in');
    });
  }catch(err){
    console.error(err);
    typeLine('Static crackles; Chunklet hides. Try again.', ()=>setStatus('Temporary hiccup.', true));
  }finally{
    setTimeout(()=> trigger.classList.remove('pressed'), 140);
    busy = false;
  }
}

function typeLine(text, done){
  typing = true;
  document.getElementById('out').classList.add('typing');
  lineSpan.textContent = '';
  cursorSpan.classList.remove('hidden');
  let i=0;
  const speed = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--talk-speed'),10) || 28;
  function step(){
    // Simulate old terminal: occasionally insert a tiny jitter
    const jitter = (i%7===0)? Math.random()*12 : 0;
    lineSpan.textContent = text.slice(0,i);
    i++;
    if(i<=text.length){
      setTimeout(step, speed + jitter);
    }else{
      typing = false;
      document.getElementById('out').classList.remove('typing');
      if(typeof done === 'function') done();
    }
  }
  step();
}

/* Audio + mouth sync */
function ensureCtx(){
  if(!audioCtx){
    audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  }
  if(audioCtx.state === 'suspended') audioCtx.resume();
}
async function playAudio(b64){
  ensureCtx();
  const raw = atob(b64.replace(/^data:audio\/[a-zA-Z0-9.+-]+;base64,/, ''));
  const buf = new Uint8Array(raw.length);
  for(let i=0;i<raw.length;i++) buf[i]=raw.charCodeAt(i);
  const decoded = await audioCtx.decodeAudioData(buf.buffer);
  currentSource = audioCtx.createBufferSource();
  currentSource.buffer = decoded;
  currentSource.connect(audioCtx.destination);
  if(!timings.length) fakeTimingsFromText(lastText);
  startMouth();
  startTime = audioCtx.currentTime;
  currentSource.start();
  currentSource.onended = () => { stopMouth(); };
}

function stopAudio(){
  if(currentSource){
    try{currentSource.stop();}catch{}
    currentSource.disconnect();
    currentSource = null;
  }
}

function startMouth(){
  document.body.classList.add('talking');
  cancelAnimationFrame(raf);
  animateMouth();
}
function stopMouth(){
  document.body.classList.remove('talking');
  cancelAnimationFrame(raf);
  mouth.style.transform = 'scaleY(0.65)';
}

function animateMouth(){
  const now = audioCtx ? (audioCtx.currentTime - startTime) : performance.now()/1000;
  if(timings.length){
    let open = 0.25;
    for(let i=0;i<timings.length;i++){
      if(now >= timings[i].t) open = timings[i].open;
      else break;
    }
    // Clamp
    open = Math.max(0, Math.min(1, open));
    const scale = 0.35 + open*0.85;
    mouth.style.transform = `scaleY(${scale})`;
  }
  raf = requestAnimationFrame(animateMouth);
}

/* Heuristic phoneme timing approximation */
function fakeTimingsFromText(text){
  const est = Math.max(6, Math.min(30, Math.round(text.length/3)));
  const total = Math.min(6, Math.max(2.8, text.length/18));
  const step = total/est;
  timings = [];
  for(let i=0;i<=est;i++){
    const open = (i%2)? 1 : 0.05 + Math.random()*0.15;
    timings.push({t:i*step, open});
  }
}

/* Events */
trigger.addEventListener('click', summon);
document.addEventListener('keydown',(e)=>{
  if(e.key === ' ' || e.key === 'Enter'){
    if(document.activeElement !== trigger) trigger.focus();
    summon();
  }
});

/* Optional: first auto‑load (comment out if not wanted) */
// summon();

</script>
</body>
</html>
