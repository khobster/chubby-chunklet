<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Chubby Chunklet</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;700&display=swap" rel="stylesheet">
<style>
  :root {
    --bg:#eef1f3;
    --dark:#222;
    --accent:#ffb400;
    --accent-shadow:#d69700;
  }
  body {
    margin:0;
    font-family:"Inter",system-ui,sans-serif;
    background:var(--bg);
    display:flex;
    flex-direction:column;
    align-items:center;
    padding:60px 20px 120px;
    color:var(--dark);
  }
  h1 {margin:0 0 6px;font-size:42px;letter-spacing:.5px;}
  .tag {margin:0 0 50px;font-size:15px;opacity:.7;}
  button {
    cursor:pointer;
    border:none;
    background:#243141;
    color:#fff;
    font-size:20px;
    padding:22px 70px;
    border-radius:50px;
    letter-spacing:.5px;
    box-shadow:0 12px 28px rgba(0,0,0,.22);
    transition:transform .2s, box-shadow .2s;
  }
  button:hover {transform:translateY(-4px);box-shadow:0 16px 34px rgba(0,0,0,.28);}
  button:active {transform:scale(.93);box-shadow:0 8px 18px rgba(0,0,0,.35);}
  .figure-wrapper {
    position:relative;
    width:260px;
    height:360px;
    margin:0 0 46px;
    perspective:900px;
  }
  /* Shadow / ground */
  .ground {
    position:absolute;
    left:50%;top:100%;
    transform:translate(-50%, -40%);
    width:180px;height:42px;
    background:radial-gradient(circle at 50% 50%,rgba(0,0,0,.28),rgba(0,0,0,0));
    filter:blur(8px);
    opacity:.42;
    transition:opacity .4s;
  }
  .chunklet {
    --pop:0;
    position:absolute;
    left:50%;top:55%;
    transform:translate(-50%,-50%) translateY(calc(var(--pop)*-40px));
    width:190px;
    transition:transform .5s cubic-bezier(.19,1,.22,1);
  }
  .chunklet.pop {--pop:1;}
  .speech {
    font-size:18px;
    background:#fff;
    padding:18px 22px;
    border-radius:16px;
    max-width:560px;
    margin-top:40px;
    box-shadow:0 8px 24px rgba(0,0,0,.15);
    min-height:92px;
    line-height:1.4;
    white-space:pre-wrap;
  }
  .status {font-size:14px;margin-top:14px;opacity:.65;}
  .mouth {
    transform-origin:50% 50%;
  }
  .talking .mouth {
    animation:mouthIdle .9s ease-in-out infinite;
  }
  @keyframes mouthIdle {
    0%,100% {transform:scaleY(.65);}
    50% {transform:scaleY(.9);}
  }
  .hidden {display:none;}
  .small-note {font-size:12px;opacity:.55;margin-top:30px;}
  .error {color:#c0392b;}
  /* Accessibility focus */
  button:focus-visible {outline:3px solid #ffcf4d;outline-offset:3px;}
</style>
</head>
<body>
  <h1>Chubby Chunklet</h1>
  <p class="tag">Knock / pull the string. Chunklet mutters something odd every time.</p>

  <div class="figure-wrapper">
    <!-- The figure is an SVG so we can animate the mouth path scale -->
    <svg id="chunklet" class="chunklet" viewBox="0 0 200 300" aria-hidden="true">
      <!-- body shadow / depth -->
      <defs>
        <linearGradient id="torsoGrad" x1="0" x2="0" y1="0" y2="1">
          <stop stop-color="#ffd654" offset="0"/>
          <stop stop-color="#ffb400" offset=".75"/>
        </linearGradient>
        <linearGradient id="headGrad" x1="0" x2="0" y1="0" y2="1">
          <stop stop-color="#ffd9cf" offset="0"/>
          <stop stop-color="#f5bcae" offset="1"/>
        </linearGradient>
      </defs>

      <!-- subtle drop shadow ellipse behind -->
      <ellipse cx="100" cy="240" rx="78" ry="26" fill="rgba(0,0,0,.15)"/>

      <!-- torso (yellow) -->
      <g filter="url(#torsoShadow)">
        <path d="M55 150 Q100 120 145 150 L155 245 Q100 270 45 245 Z"
              fill="url(#torsoGrad)" stroke="#d09a00" stroke-width="3"/>
        <path d="M55 150 Q100 120 145 150 Q100 160 55 150"
              fill="rgba(255,255,255,.25)"/>
      </g>

      <!-- head -->
      <g id="headGroup">
        <circle cx="100" cy="115" r="55" fill="url(#headGrad)" stroke="#c48d7f" stroke-width="3"/>
        <!-- swirl hair -->
        <path d="M105 72 q15 10 0 24 q-12 10 -18 0 q-4 -8 5 -13"
              fill="none" stroke="#3b2b29" stroke-width="5" stroke-linecap="round" stroke-linejoin="round"/>
        <!-- eyes -->
        <circle cx="80" cy="110" r="6" fill="#2a1c1b"/>
        <circle cx="120" cy="110" r="6" fill="#2a1c1b"/>
        <!-- mouth (animated) -->
        <ellipse id="mouth" class="mouth" cx="100" cy="140" rx="15" ry="11" fill="#111"/>
      </g>
    </svg>
    <div class="ground" id="ground"></div>
  </div>

  <button id="goBtn" type="button">KNOCK / PULL STRING</button>

  <div id="speech" class="speech"></div>
  <div id="status" class="status"></div>
  <div class="small-note">Output is whimsical & safe. Animation sync approximated from phoneme timings.</div>

<script>
const ENDPOINT = 'https://pu30nzsu59.execute-api.us-east-1.amazonaws.com/dev/chunklet'; // update if redeployed

const btn     = document.getElementById('goBtn');
const speech  = document.getElementById('speech');
const statusEl= document.getElementById('status');
const chunklet= document.getElementById('chunklet');
const mouthEl = document.getElementById('mouth');
const ground  = document.getElementById('ground');

let audioCtx;
let currentSource;
let talkRAF;
let timings = []; // [{t:seconds, open:0..1}]
let startTime = 0;

function setStatus(msg, isError=false){
  statusEl.textContent = msg;
  statusEl.classList.toggle('error', !!isError);
}

function sanitizeEnding(text){
  // Remove overdone bang if model keeps adding them:
  return text.replace(/!+$/,'').trim() + '.';
}

async function fetchChunklet(){
  btn.disabled = true;
  setStatus('Summoning Chunklet...');
  chunklet.classList.remove('pop');
  ground.style.opacity = 0.2;
  speech.textContent = '';
  try{
    const r = await fetch(ENDPOINT);
    if(!r.ok) throw new Error('Server '+r.status);
    const data = await r.json();
    // Data expected: { text, audioBase64?, timings? }
    let line = (data.text||'').trim();
    if(!line) line = 'Silence swirls.';
    line = sanitizeEnding(line);
    speech.textContent = line;

    // Appear / pop
    requestAnimationFrame(()=> {
      chunklet.classList.add('pop');
      ground.style.opacity = 0.42;
    });

    if(data.audioBase64){
      timings = Array.isArray(data.timings)? data.timings : [];
      await playAudio(data.audioBase64);
    } else {
      // Fallback: fake simple mouth animation for 3 seconds
      fakeTimingsFromText(line);
      startMouth();
      setTimeout(stopMouth, 3000);
    }
    setStatus('Ready.');
  }catch(e){
    console.error(e);
    speech.textContent = 'Chunklet sneezes in Morse code... try again.';
    setStatus('Temporary hiccup.', true);
  }finally{
    btn.disabled = false;
  }
}

function ensureAudioCtx(){
  if(!audioCtx){
    audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  }
  if(audioCtx.state === 'suspended') audioCtx.resume();
}

/* ----- Audio Playback with mouth sync ----- */
async function playAudio(b64){
  ensureAudioCtx();
  stopAudio();
  startTime = 0;
  const binary = atob(b64.replace(/^data:audio\/[a-zA-Z0-9.+-]+;base64,/, ''));
  const len = binary.length;
  const buf = new Uint8Array(len);
  for(let i=0;i<len;i++) buf[i] = binary.charCodeAt(i);
  const decoded = await audioCtx.decodeAudioData(buf.buffer);
  currentSource = audioCtx.createBufferSource();
  currentSource.buffer = decoded;
  currentSource.connect(audioCtx.destination);
  // If no timings, approximate:
  if(!timings.length){
    fakeTimingsFromText(speech.textContent);
  }
  startMouth();
  startTime = audioCtx.currentTime;
  currentSource.start();
  currentSource.onended = ()=> {
    stopMouth();
  };
}

function stopAudio(){
  if(currentSource){
    try{currentSource.stop();}catch{}
    currentSource.disconnect();
    currentSource = null;
  }
  stopMouth();
}

/* ----- Mouth animation ----- */
function startMouth(){
  document.body.classList.add('talking');
  cancelAnimationFrame(talkRAF);
  talkLoop();
}

function stopMouth(){
  document.body.classList.remove('talking');
  cancelAnimationFrame(talkRAF);
  mouthEl.setAttribute('ry','11');
}

function talkLoop(){
  const now = audioCtx ? (audioCtx.currentTime - startTime) : (performance.now()/1000);
  // Find most recent timing <= now
  if(timings.length){
    // timings sorted
    let open = 0.3;
    for(let i=0;i<timings.length;i++){
      if(now >= timings[i].t) open = timings[i].open;
      else break;
    }
    // Smooth open value
    const ry = 6 + open*8;    // vertical size
    const rx = 11 + open*5;   // horizontal subtle
    mouthEl.setAttribute('ry', ry.toFixed(2));
    mouthEl.setAttribute('rx', rx.toFixed(2));
  }
  talkRAF = requestAnimationFrame(talkLoop);
}

/* Approximate timings from text if backend didn't provide real ones */
function fakeTimingsFromText(txt){
  const syllables = Math.max(4, Math.min(24, Math.round(txt.split(/\b[aeiouyAEIOUY]/).length*0.9)));
  const total = Math.min(6, Math.max(2.5, txt.length/18));
  const step = total / syllables;
  timings = [];
  for(let i=0;i<=syllables;i++){
    const t = i*step;
    const open = (i%2) ? 1 : 0.1;
    timings.push({t, open});
  }
}

/* ----- Event bindings ----- */
btn.addEventListener('click', fetchChunklet);

/* Optional: prefetch first line on load */
setTimeout(()=>{ /* You can auto-load: fetchChunklet(); */ }, 600);

</script>
</body>
</html>
