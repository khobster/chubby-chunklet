<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>chubby chunklet</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <link rel="icon" type="image/png" href="favicon.png" />
  <link rel="apple-touch-icon" href="favicon.png" />

  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Emilys+Candy&family=Rubik:wght@400;500;700&family=DM+Sans:wght@400;500;700&display=swap" rel="stylesheet" />

  <style>
    :root{
      /* Backend */
      --endpoint: https://pu30nzsu59.execute-api.us-east-1.amazonaws.com/dev/chunklet;

      /* Chunklet sprite / mouth (calibrated) */
      --figure-scale:1.15;
      --mouth-top:39%;
      --mouth-left:49%;
      --mouth-w:20px;
      --mouth-h:20px;
      --mouth-scale-0:.05;

      /* Eyes — lower & farther apart (tweak as needed) */
      --eye-top:30.2%;
      --eye-left:45.2%;
      --eye-right:53.3%;
      --eye-size:5.2px;

      /* Typing */
      --char-ms:18;

      /* Door anchors (normalized, calibrated) */
      --door-x: 0.472;
      --door-y: 0.579;
      --door-w: 0.099;
      --door-h: 0.248;

      /* Bubble layout */
      --output-top-fallback: 8vmin;
      --bubble-gap: 18px;
      --tail-x: 50%;
    }

    *{box-sizing:border-box}
    html,body{
      margin:0;padding:0;
      font-family:Rubik, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background:#000;color:#fff; -webkit-font-smoothing:antialiased;
      overflow:hidden; height:100%; width:100%;
    }

    /* ===== Intro overlay ===== */
    .intro{
      position:fixed; inset:0; z-index:1000;
      display:flex; align-items:center; justify-content:center;
      background:#000;
      transition:opacity .6s ease;
      cursor:pointer;
    }
    .intro.hidden{ opacity:0; pointer-events:none; }
    .intro-bg{
      position:absolute; inset:0; width:100%; height:100%;
      object-fit:contain;              /* not zoomed in */
      user-select:none; -webkit-user-drag:none;
    }

    .scene-container{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:#4a7ba7; }
    .scene-bg{ width:100%; height:100%; position:relative; display:flex; align-items:center; justify-content:center; perspective:900px; }
    .scene-bg img{ width:100%; height:100%; object-fit:cover; display:block; user-select:none; -webkit-user-drag:none; }

    /* Door */
    .door-container{
      position:absolute; left:50%; top:52%; width:140px; height:180px;
      transform:translate(-50%, -50%); cursor:pointer; z-index:50;
    }
    .door-left, .door-right{
      position:absolute; width:50%; height:100%;
      background:#3d2418; border:3px solid #2d1810;
      transition:transform 0.8s cubic-bezier(0.68,-0.55,0.265,1.55);
      box-shadow: inset 0 0 20px rgba(0,0,0,0.4), 0 0 10px rgba(0,0,0,0.8);
      backface-visibility:hidden; transform-style:preserve-3d;
    }
    .door-left{ left:0;  transform-origin:left center;  border-right:2px solid #1a0e08; }
    .door-right{right:0;  transform-origin:right center; border-left: 2px solid #1a0e08; }
    .door-panel{ position:absolute; background:#2d1810; border:2px solid #1a0e08;
      box-shadow: inset 2px 2px 4px rgba(0,0,0,0.4), inset -1px -1px 2px rgba(61,36,24,0.3); }
    .door-left .panel-top{   width:65%; height:22%; top:15%; left:17.5%;}
    .door-left .panel-mid{   width:65%; height:22%; top:41%; left:17.5%;}
    .door-left .panel-bottom{width:65%; height:22%; top:67%; left:17.5%;}
    .door-right .panel-top{   width:65%; height:22%; top:15%; right:17.5%;}
    .door-right .panel-mid{   width:65%; height:22%; top:41%; right:17.5%;}
    .door-right .panel-bottom{width:65%; height:22%; top:67%; right:17.5%;}
    .door-open .door-left{ transform:rotateY(85deg); }
    .door-open .door-right{ transform:rotateY(-85deg); }

    /* Chunklet */
    .chunklet-container{
      position:absolute; transform:translate(-50%, -30px);
      opacity:0; transition:opacity 0.3s; z-index:60; pointer-events:none;
    }
    .chunklet-container.active{ opacity:1; }
    .chunklet-wrap{ position:relative; width:calc(100px*var(--figure-scale)); height:calc(130px*var(--figure-scale)); display:flex; align-items:flex-end; justify-content:center; }
    .chunklet-img{ width:calc(90px*var(--figure-scale)); max-width:100%; user-select:none; -webkit-user-drag:none; filter:drop-shadow(0 8px 16px rgba(0,0,0,.6)); image-rendering:-webkit-optimize-contrast; }

    .ground-shadow{
      position:absolute; left:50%; bottom:-2px; width:88px; height:18px; transform:translateX(-50%) scale(0.6);
      background:radial-gradient(ellipse at center, rgba(0,0,0,.45) 0%, rgba(0,0,0,.25) 40%, rgba(0,0,0,0) 70%);
      filter:blur(2px); opacity:0; pointer-events:none;
    }

    /* Mouth overlay */
    .mouth-overlay{ position:absolute; top:var(--mouth-top); left:var(--mouth-left); width:var(--mouth-w); height:var(--mouth-h); transform:translate(-50%,-50%); display:flex; align-items:center; justify-content:center; pointer-events:none; }
    .mouth-overlay svg{width:100%;height:100%}
    #mouth{transform-origin:50% 50%; transform:scale(1, var(--mouth-scale-0))}

    /* Eyes overlay */
    .eyes-overlay{ position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; }
    .eye{
      position:absolute;
      width:calc(var(--eye-size)*var(--figure-scale));
      height:calc(var(--eye-size)*var(--figure-scale));
      background:#111; border-radius:50%;
      transform:translate(-50%, -50%);
      animation:blink 5s infinite;
    }
    .eye.left{  top:var(--eye-top); left:var(--eye-left); }
    .eye.right{ top:var(--eye-top); left:var(--eye-right); animation-delay:.12s; }
    @keyframes blink{
      0%, 94%, 100% { transform:translate(-50%,-50%) scaleY(1); }
      95%, 96%      { transform:translate(-50%,-50%) scaleY(.25); }
    }

    /* ===== Speech bubble ===== */
    .output-container{
      position:fixed; left:50%; transform:translateX(-50%);
      width:auto; max-width:90vw;
      z-index:40; opacity:0; transition:opacity 0.45s;
      pointer-events:none; top:var(--output-top-fallback);
      text-align:center;
    }
    .output-container.active{ opacity:1; }

    .bubble-wrap{ position:relative; display:inline-block; }
    .speech-bubble{
      position:relative;
      background:#fff;
      border:6px solid #000;
      border-radius:32px;
      padding:18px 26px 18px 22px;
      color:#111;
      box-shadow:0 6px 0 #000, 0 14px 30px rgba(0,0,0,.35);
      display:inline-block;
      max-width:86vw;
    }
    .bubble-tail{
      position:absolute;
      bottom:-2px;
      left:var(--tail-x);
      transform:translate(-50%, 100%);
      width:44px; height:28px;
      overflow:visible; pointer-events:none;
    }

    /* Phrase text */
    .output{
      font-family:"Emilys Candy", Rubik, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      text-transform:uppercase;
      font-weight:400;
      font-size:clamp(22px, 2.4vw, 36px);
      line-height:1.04;
      letter-spacing:-0.06em;
      word-spacing:-0.04em;
      color:#111;
      margin:0;
      white-space:pre-wrap;
      text-shadow:none;
      text-align:center;
    }
    .cursor{
      display:inline-block; width:.5ch; height:1.05em; background:#111;
      vertical-align:text-bottom; animation:blinkCaret 1s steps(1,end) infinite; border-radius:2px;
    }
    @keyframes blinkCaret{0%,55%{opacity:1}56%,100%{opacity:0}}
    .typing .cursor{animation:none}

    .output .work-tag{
      opacity:.95; text-transform:uppercase;
      margin-left:.6em; font-size:.66em;
      letter-spacing:-0.06em; word-spacing:-0.04em;
      color:#333; display:block; margin-top:10px; text-shadow:none;
    }

    /* Entrance */
    @keyframes emergePop {
      0%   { transform:translate(-50%,-60px) scale(.86,.92) rotate(-3deg); opacity:0; filter:brightness(.85); }
      40%  { transform:translate(-50%,-28px) scale(1.06,.94) rotate(-2deg); opacity:1; }
      60%  { transform:translate(-50%,-18px) scale(.96,1.04) rotate(2deg); }
      100% { transform:translate(-50%,-12px) scale(1,1) rotate(0deg); }
    }
    @keyframes waddleDown {
      0%   { transform:translate(-50%,-12px) rotate(0deg); }
      10%  { transform:translate(-50%,   0px) rotate(-3deg); }
      20%  { transform:translate(-50%,  10px) rotate(3deg); }
      30%  { transform:translate(-50%,  20px) rotate(-3deg); }
      40%  { transform:translate(-50%,  30px) rotate(3deg); }
      55%  { transform:translate(-50%,  45px) rotate(-2deg); }
      70%  { transform:translate(-50%,  58px) rotate(2deg); }
      85%  { transform:translate(-50%,  66px) rotate(-1deg) scale(1.02,.98); }
      100% { transform:translate(-50%,  70px) rotate(0deg)  scale(1,1); }
    }
    @keyframes shadowEmerge { 0%{opacity:0; transform:translateX(-50%) scale(0.4);} 60%{opacity:.55; transform:translateX(-50%) scale(0.75);} 100%{opacity:.65; transform:translateX(-50%) scale(0.85);} }
    @keyframes shadowWaddle { 0%{opacity:.65; transform:translateX(-50%) scale(0.85);} 25%{opacity:.70; transform:translateX(-50%) scale(0.95);} 50%{opacity:.60; transform:translateX(-50%) scale(0.88);} 75%{opacity:.72; transform:translateX(-50%) scale(1.00);} 100%{opacity:.68; transform:translateX(-50%) scale(1.05);} }
    .chunklet-container.emerge { animation:emergePop .7s cubic-bezier(.22,1,.36,1) forwards; }
    .chunklet-container.waddle { animation:waddleDown 2.4s cubic-bezier(.22,1,.36,1) forwards; }
    .chunklet-container.emerge .ground-shadow { animation:shadowEmerge .7s ease-out forwards; }
    .chunklet-container.waddle .ground-shadow { animation:shadowWaddle 2.4s ease-out forwards; }

    /* ===== Context board (British Open minimal) ===== */
    .context-card{
      position:fixed;
      left:50%; transform:translateX(-50%);
      z-index:45; opacity:0; pointer-events:none;
      transition:opacity .28s ease;
      max-width:92vw;
    }
    .context-card.on{ opacity:1; }

    .ctx-board{
      display:flex; align-items:flex-start; gap:12px;
      background:#f5ce3e;
      border:6px solid #0a0a0a;
      border-radius:12px;
      padding:12px 16px;
      box-shadow:0 6px 0 #000, 0 14px 26px rgba(0,0,0,.35), inset 0 -3px 0 rgba(0,0,0,.12);
      font-family: "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color:#111;
    }
    .ctx-badge{
      flex:0 0 auto;
      align-self:flex-start;
      padding:6px 10px 6px;
      border:3px solid #0a0a0a;
      border-radius:8px;
      background:#ffe58a;
      font:700 12px/1 "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      letter-spacing:.12em;
    }
    .ctx-text{
      flex:1 1 auto;
      font:500 15px/1.35 "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      letter-spacing:.01em;
      text-wrap:pretty;
    }
    .ctx-meta{
      flex:0 0 auto;
      align-self:flex-end;
      font:700 11px/1 "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      letter-spacing:.12em; text-transform:uppercase;
      padding-left:10px;
      border-left:3px solid #0a0a0a22;
      white-space:nowrap;
    }

    @media(max-width:600px){
      .output-container{ max-width:94vw; }
      .speech-bubble{ border-radius:28px; padding:14px 18px 14px 16px; }
      .output{ font-size:clamp(18px, 4.1vw, 28px); line-height:1.07; }
      .ctx-text{ font-size:14px; }
      .ctx-badge{ font-size:11px; }
      .ctx-meta{ font-size:10px; }
    }
  </style>
</head>
<body>
  <!-- Intro audio -->
  <audio id="introTheme" src="chunklet_theme_song.mp3" preload="auto" playsinline autoplay></audio>

  <!-- Tap anywhere to start -->
  <div class="intro" id="introOverlay" role="dialog" aria-label="Intro (tap anywhere to start)">
    <img class="intro-bg" src="introscreen.png" alt="">
  </div>

  <audio id="clickSnd" src="click.mp3" preload="auto"></audio>

  <div class="scene-container" aria-hidden="true">
    <div class="scene-bg">
      <img src="skullbones.png" alt="Scene background" />

      <!-- Door -->
      <div class="door-container" id="doorTrigger" aria-label="Open the door" role="button" tabindex="0">
        <div class="door-left">
          <div class="door-panel panel-top"></div>
          <div class="door-panel panel-mid"></div>
          <div class="door-panel panel-bottom"></div>
        </div>
        <div class="door-right">
          <div class="door-panel panel-top"></div>
          <div class="door-panel panel-mid"></div>
          <div class="door-panel panel-bottom"></div>
        </div>
      </div>

      <!-- Chunklet -->
      <div class="chunklet-container" id="chunkletContainer" aria-hidden="true">
        <div class="chunklet-wrap">
          <img src="littleboytalk.png" alt="Chubby Chunklet" class="chunklet-img" />
          <div class="mouth-overlay">
            <svg viewBox="0 0 100 100" aria-hidden="true">
              <ellipse id="mouth" cx="50" cy="50" rx="26" ry="24" fill="#111"/>
            </svg>
          </div>
          <div class="eyes-overlay">
            <span class="eye left"></span>
            <span class="eye right"></span>
          </div>
          <div class="ground-shadow"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Speech bubble output -->
  <div class="output-container" id="outputContainer" aria-live="polite">
    <div class="bubble-wrap">
      <div class="speech-bubble" id="bubble">
        <div class="output" id="output">
          <span id="typed"></span><span id="cursor" class="cursor"></span>
        </div>
      </div>
      <svg class="bubble-tail" id="bubbleTail" viewBox="0 0 44 28" preserveAspectRatio="xMidYMid meet" aria-hidden="true">
        <path d="M4,2 C 14,20 30,20 40,2" fill="#fff" stroke="#000" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/>
      </svg>
    </div>
  </div>

  <!-- Context board -->
  <div class="context-card" id="contextCard" aria-hidden="true">
    <div class="ctx-board">
      <div class="ctx-badge">CONTEXT</div>
      <div class="ctx-text" id="ctxText"></div>
      <div class="ctx-meta" id="ctxMeta"></div>
    </div>
  </div>

  <script>
    /* ===== CONFIG ===== */
    const ENDPOINT = (getComputedStyle(document.documentElement).getPropertyValue('--endpoint') || '').trim();
    const QUERY    = '?style=canon&modern=0&accent=scottish&context=1';

    const CHAR_MS  = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--char-ms'),10) || 20;
    const DOOR_SWING_MS = 800, EMERGE_MS = 700, WADDLE_MS = 2400;

    /* show context a beat after reading; let it linger longer */
    const CONTEXT_AFTER_MS = 900;
    const LINGER_AFTER_CONTEXT_MS = 14000;

    /* ===== Elements ===== */
    const introOverlay      = document.getElementById('introOverlay');
    const introTheme        = document.getElementById('introTheme');

    const doorTrigger       = document.getElementById('doorTrigger');
    const chunkletContainer = document.getElementById('chunkletContainer');
    const outputContainer   = document.getElementById('outputContainer');
    const bubble            = document.getElementById('bubble');
    const bubbleTail        = document.getElementById('bubbleTail');
    const typed             = document.getElementById('typed');
    const cursor            = document.getElementById('cursor');
    const mouth             = document.getElementById('mouth');
    const output            = document.getElementById('output');

    const ctxCard = document.getElementById('contextCard');
    const ctxText = document.getElementById('ctxText');
    const ctxMeta = document.getElementById('ctxMeta');

    const bgImg   = document.querySelector('.scene-bg img');
    const host    = document.querySelector('.scene-bg');
    const isIOS   = /iP(hone|od|ad)|Macintosh.*Mobile/.test(navigator.userAgent);

    let busy=false, doorOpen=false;
    const timers = new Set();
    const delay = (ms, fn) => { const id=setTimeout(()=>{timers.delete(id); fn&&fn();}, ms); timers.add(id); return id; };
    const clearTimers = ()=>{ for(const id of timers) clearTimeout(id); timers.clear(); };

    /* ===== Audio / Mouth ===== */
    let audioCtx, analyser, timeData, currentSource=null, audioEl=null, mediaSource=null, raf, animating=false, tagPlaying=false, iosAudioInitialized=false;

    const SY=[0.07,0.55,1.10,1.70,2.30], SX=[1.00,1.01,1.02,1.02,1.03];
    const THRESH_UP=[0.030,0.060,0.100,0.160], HYST_DELTA=0.018;
    const THRESH_DOWN=THRESH_UP.map(t=>Math.max(0,t-HYST_DELTA));
    const GATE_FLOOR=0.010, CLOSE_GRACE_MS=20;
    let level=0,lastChange=0;

    function ensureCtx(){ if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); if(audioCtx.state==='suspended') audioCtx.resume(); }
    function ensureAnalyser(){ ensureCtx(); if(!analyser){ analyser=audioCtx.createAnalyser(); analyser.fftSize=256; analyser.smoothingTimeConstant=0.0; timeData=new Float32Array(analyser.fftSize);} }
    function attachAnalyserToBufferSource(src){ ensureAnalyser(); try{src.disconnect();}catch(_){ } src.connect(analyser); analyser.connect(audioCtx.destination); }
    function attachAnalyserToMediaElement(){
      ensureAnalyser();
      if(isIOS && !iosAudioInitialized){ initializeIOSAudio(); return; }
      if(!audioEl){
        audioEl=document.createElement('audio');
        audioEl.style.position='absolute'; audioEl.style.left='-9999px';
        audioEl.setAttribute('playsinline',''); audioEl.setAttribute('webkit-playsinline','');
        document.body.appendChild(audioEl);
      }
      if(!mediaSource && audioCtx && audioEl){
        try{ mediaSource=audioCtx.createMediaElementSource(audioEl); mediaSource.connect(analyser); analyser.connect(audioCtx.destination); }
        catch(e){ console.warn('createMediaElementSource failed', e); }
      }
    }
    function rmsLevel(){ if(!analyser||!timeData) return 0; analyser.getFloatTimeDomainData(timeData); let s=0; for(let i=0;i<timeData.length;i++){s+=timeData[i]*timeData[i]} let r=Math.sqrt(s/timeData.length); return r<GATE_FLOOR?0:r; }
    function setLevel(n){ n=Math.max(0,Math.min(4,n|0)); if(n===level) return; level=n; mouth.style.transform=`scale(${SX[level]}, ${SY[level]})`; lastChange=performance.now(); }
    function setClosed(){ setLevel(0); }
    function startMouth(){ if(animating) return; animating=true; raf=requestAnimationFrame(tick); }
    function stopMouth(){ animating=false; cancelAnimationFrame(raf); setClosed(); }
    function tick(){
      if(!animating) return; raf=requestAnimationFrame(tick);
      const active=!!currentSource||tagPlaying, now=performance.now();
      if(active){
        if(analyser && (currentSource || (tagPlaying && mediaSource))){
          const e=rmsLevel();
          if(isIOS && e===0 && tagPlaying){ const t=(now/1000); const phase=((t*15)|0)%5; setLevel([1,2,3,2,1][phase]); return; }
          let target=level;
          while(target<4 && e>=THRESH_UP[target]) target++;
          while(target>0 && e<THRESH_DOWN[target-1]) target--;
          if(target<level && (now-lastChange)<CLOSE_GRACE_MS) target=level;
          setLevel(target);
        }else{ const t=(now/1000); const phase=((t*15)|0)%5; setLevel([1,2,3,2,1][phase]); }
        return;
      }
      const t=(now/1000); const phase=((t*13)|0)%4; const rand=Math.random();
      setLevel(phase===0?0:phase===1?(rand<.7?1:2):phase===2?(rand<.6?2:3):(rand<.5?3:4));
    }

    function initializeIOSAudio(){ if(iosAudioInitialized) return; try{ ensureCtx(); iosAudioInitialized=true; }catch(_){} }

    /* ===== Intro behavior (autoplay robust) ===== */
    function tryPlayIntro(){
      try{
        introTheme.loop = true;
        // Priming trick: try unmuted; if blocked, start muted then unmute on first user action.
        const start = async () => {
          try{
            introTheme.muted = false;
            await introTheme.play();
          }catch(_){
            try{
              introTheme.muted = true;
              await introTheme.play(); // silent loop until gesture
            }catch(__){}
          }
        };
        start();
      }catch(_){}
    }

    // Kick attempts on load & visibility changes (desktop will start; mobile may wait for gesture)
    if (document.readyState === 'complete' || document.readyState === 'interactive') tryPlayIntro();
    else document.addEventListener('DOMContentLoaded', tryPlayIntro);
    document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState==='visible' && introTheme.paused) tryPlayIntro(); });

    function startApp(){
      // unmute & fade out theme, then stop
      if (introTheme.muted) { try{ introTheme.muted = false; }catch(_){} }
      const dur = 900;
      const v0 = introTheme.volume || 1;
      const t0 = performance.now();
      function fade(){
        const t = performance.now() - t0;
        const v = Math.max(0, v0 * (1 - t/dur));
        introTheme.volume = v;
        if(t < dur) requestAnimationFrame(fade);
        else { try{ introTheme.pause(); }catch(_){}
          introTheme.currentTime = 0; introTheme.volume = 1;
        }
      }
      requestAnimationFrame(fade);
      requestAnimationFrame(()=>introOverlay.classList.add('hidden'));
    }

    // tap anywhere to start
    ['click','touchstart','pointerdown','keydown'].forEach(ev=>{
      introOverlay.addEventListener(ev, ()=>{
        // If it was silently looping, make it audible right away
        if (!introOverlay.classList.contains('hidden') && !introTheme.paused && introTheme.muted){
          try{ introTheme.muted = false; }catch(_){}
        }
        startApp();
      }, {once:true, passive:true});
    });

    /* ===== Unlock audio one-time (for mouth/tts) ===== */
    function unlockAudioOnce(){
      try{
        ensureCtx();
        if(isIOS){ initializeIOSAudio(); }
        else { const b=audioCtx.createBuffer(1,1,22050); const s=audioCtx.createBufferSource(); s.buffer=b; s.connect(audioCtx.destination); s.start(0); }
      }catch(_){}
      document.removeEventListener('touchstart', unlockAudioOnce);
      document.removeEventListener('click', unlockAudioOnce);
    }
    document.addEventListener('touchstart', unlockAudioOnce, {once:true, passive:true});
    document.addEventListener('click', unlockAudioOnce, {once:true});

    /* ===== Layout (door + bubble + context) ===== */
    const DOOR={
      get x(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--door-x'))||0.5; },
      get y(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--door-y'))||0.55; },
      get w(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--door-w'))||0.10; },
      get h(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--door-h'))||0.25; }
    };

    const host = document.querySelector('.scene-bg');
    const bgImg = host.querySelector('img');

    function positionDoorAndChunklet(){
      const hostRect=host.getBoundingClientRect();
      const natW=bgImg.naturalWidth, natH=bgImg.naturalHeight;

      const scale = (natW&&natH) ? Math.max(hostRect.width/natW, hostRect.height/natH) : 1;
      const dispW = (natW||hostRect.width)*scale;
      const dispH = (natH||hostRect.height)*scale;
      const offsetX=(hostRect.width-dispW)/2, offsetY=(hostRect.height-dispH)/2;

      const cx = hostRect.left + offsetX + dispW*DOOR.x;
      const cy = hostRect.top  + offsetY + dispH*DOOR.y;
      const dw = dispW*DOOR.w, dh = dispH*DOOR.h;

      Object.assign(doorTrigger.style, { left:(cx-hostRect.left)+'px', top:(cy-hostRect.top)+'px', width:dw+'px', height:dh+'px' });

      const exitY = cy + dh*0.35;
      Object.assign(chunkletContainer.style, { left:(cx-hostRect.left)+'px', top:(exitY-hostRect.top)+'px', transform:'translate(-50%,-30px)' });

      placeBubble(); placeContext();
    }

    function placeBubble(){
      const cardRect = outputContainer.getBoundingClientRect();
      const guyRect  = chunkletContainer.getBoundingClientRect();
      if(!(cardRect.width && guyRect.width)) return;

      const desiredBottom = Math.max(8, guyRect.top - parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--bubble-gap')));
      const newTop = Math.max(8, Math.round(desiredBottom - cardRect.height));
      outputContainer.style.top = newTop + 'px';

      const cardLeft = cardRect.left;
      const tailPx = (guyRect.left + guyRect.width/2) - cardLeft;
      const tailPct = Math.max(8, Math.min(92, tailPx / cardRect.width * 100));
      outputContainer.style.setProperty('--tail-x', tailPct + '%');
    }

    function placeContext(){
      const ctxRect = ctxCard.getBoundingClientRect();
      const cardRect = outputContainer.getBoundingClientRect();
      if(!(cardRect.width && (ctxRect.width || ctxText.textContent))) return;

      const gap = 10;
      const newTop = Math.max(8, Math.round(cardRect.top - ctxRect.height - gap));
      ctxCard.style.top = newTop + 'px';

      ctxCard.style.left = '50%';
      ctxCard.style.transform = 'translateX(-50%)';

      const maxW = Math.min(cardRect.width * 0.96, window.innerWidth * 0.92);
      ctxCard.style.maxWidth = maxW + 'px';
    }

    const ro1 = new ResizeObserver(()=>{ placeBubble(); placeContext(); }); ro1.observe(outputContainer);
    const ro2 = new ResizeObserver(()=>{ placeContext(); }); ro2.observe(ctxCard);

    function onReadyToPosition(){
      positionDoorAndChunklet();
      setTimeout(positionDoorAndChunklet, 50);
      setTimeout(positionDoorAndChunklet, 250);
    }
    if(bgImg.complete) onReadyToPosition(); else bgImg.addEventListener('load', onReadyToPosition);
    window.addEventListener('resize', positionDoorAndChunklet);
    window.addEventListener('orientationchange', positionDoorAndChunklet);

    /* ===== Door flow ===== */
    function openDoor(){
      if(doorOpen) return;
      clearTimers();
      positionDoorAndChunklet();
      doorOpen=true; doorTrigger.classList.add('door-open');

      setTimeout(()=>{
        chunkletContainer.classList.add('active','emerge');
        setTimeout(()=>{
          chunkletContainer.classList.remove('emerge');
          chunkletContainer.classList.add('waddle');
        }, EMERGE_MS);
      }, DOOR_SWING_MS);
    }
    function closeDoor(){
      if(!doorOpen) return; doorOpen=false;
      chunkletContainer.classList.remove('active','emerge','waddle');
      outputContainer.classList.remove('active');
      ctxCard.classList.remove('on');
      setTimeout(()=>{ doorTrigger.classList.remove('door-open'); busy=false; }, 500);
    }

    function typeOut(text, done){
      typed.textContent='';
      output.classList.add('typing');
      (function loop(i=0){
        typed.textContent = text.slice(0,i);
        placeBubble();
        if(i<text.length){
          setTimeout(()=>loop(i+1), CHAR_MS + ((i%7)?0:Math.random()*10));
        }else{
          output.classList.remove('typing');
          placeBubble();
          done && done();
        }
      })();
    }

    async function fetchLineWithRetry(){
      const urls = [
        ENDPOINT + QUERY,                             // full (tts+context)
        ENDPOINT + '?style=canon&modern=0&context=1'  // no accent hint, keep context
      ];
      let lastErr;
      for(let i=0;i<urls.length;i++){
        try{
          const res = await fetch(urls[i], { cache:'no-store' });
          if(!res.ok) throw new Error('HTTP '+res.status);
          return await res.json();
        }catch(e){
          lastErr = e;
          await new Promise(r=>setTimeout(r, 300 + Math.random()*400));
        }
      }
      throw lastErr || new Error('Network error');
    }

    function showWorkMeta(work, author){
      const old = document.querySelector('#output .work-tag'); if(old) old.remove();
      if(!work && !author) return;
      const span=document.createElement('span'); span.className='work-tag';
      span.textContent='— '+[work,author].filter(Boolean).join(' · ');
      output.appendChild(span);
      placeBubble();
    }

    async function summon(){
      if(busy) return; busy=true;

      ctxCard.classList.remove('on');
      ctxText.textContent=''; ctxMeta.textContent='';
      outputContainer.classList.remove('active');
      typed.textContent='';

      openDoor();
      await new Promise(r=>setTimeout(r, DOOR_SWING_MS + EMERGE_MS + WADDLE_MS));

      try{
        const data = await fetchLineWithRetry();

        const text = (data.text||'').trim();
        const context = (data.context||'') || '';
        const meta = [data.work, data.author].filter(Boolean).join(' · ');

        outputContainer.classList.add('active');
        placeBubble();

        typeOut(/[.?!]$/.test(text)?text:(text+'.'), async ()=>{
          const onEnd=()=>{
            showWorkMeta(data.work, data.author);

            delay(CONTEXT_AFTER_MS, ()=>{
              if(context){
                ctxText.textContent = context;
                ctxMeta.textContent = meta;
                ctxCard.classList.add('on');
                placeContext();
              }
              delay(LINGER_AFTER_CONTEXT_MS, ()=>closeDoor());
            });
          };

          if(data.audioBase64){
            try{
              ensureCtx(); ensureAnalyser();
              const bin=Uint8Array.from(atob(data.audioBase64.split(',')[1]), c=>c.charCodeAt(0));
              const buf=await audioCtx.decodeAudioData(bin.buffer);
              currentSource=audioCtx.createBufferSource();
              currentSource.buffer=buf; currentSource.playbackRate.value=1.08;
              attachAnalyserToBufferSource(currentSource);
              setClosed(); startMouth(); currentSource.start();
              currentSource.onended=()=>{ currentSource=null; stopMouth(); onEnd(); };
            }catch(_){
              setClosed(); startMouth();
              delay(Math.min(7, Math.max(2.2, text.length/16))*1000, ()=>{ stopMouth(); onEnd(); });
            }
          }else{
            setClosed(); startMouth();
            delay(Math.min(7, Math.max(2.2, text.length/16))*1000, ()=>{ stopMouth(); onEnd(); });
          }
        });

      }catch(e){
        console.error(e);
        outputContainer.classList.add('active');
        typeOut('A shy packet tripped. Tap the door to try again.');
        delay(2500, ()=>closeDoor());
      }
    }

    doorTrigger.addEventListener('click', summon);
    doorTrigger.addEventListener('keydown', e=>{ if(e.key===' '||e.key==='Enter'){ e.preventDefault(); summon(); } });

    /* init layout */
    function ready(){ positionDoorAndChunklet(); }
    if(bgImg.complete) ready(); else bgImg.addEventListener('load', ready);
  </script>
</body>
</html>
