<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>chubby chunklet</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />

<link rel="icon" type="image/png" href="favicon.png" />
<link rel="apple-touch-icon" href="favicon.png" />

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link href="https://fonts.googleapis.com/css2?family=Emilys+Candy&family=Rubik:wght@400;500;700&family=DM+Sans:wght@400;600;700&display=swap" rel="stylesheet" />

<style>
  :root{
    --endpoint: https://pu30nzsu59.execute-api.us-east-1.amazonaws.com/dev/chunklet;

    --figure-scale:1.15;
    --mouth-top:39%;
    --mouth-left:49%;
    --mouth-w:20px;
    --mouth-h:20px;
    --mouth-scale-0:.05;

    /* Eyes */
    --eye-top:34.2%;
    --eye-gap:18px;
    --eye-size:4px;

    --char-ms:18;

    --door-x: 0.472;
    --door-y: 0.579;
    --door-w: 0.099;
    --door-h: 0.248;

    --output-top-fallback: 8vmin;
    --bubble-gap: 18px;
    --tail-x: 50%;
  }

  *{box-sizing:border-box}
  html,body{
    margin:0;padding:0;
    font-family:Rubik, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    background:#000;color:#fff; -webkit-font-smoothing:antialiased;
    overflow:hidden; height:100%; width:100%;
  }

  /* INTRO */
  .intro-overlay{position:fixed; inset:0; z-index:9999; display:flex; align-items:center; justify-content:center; background:#000; cursor:pointer;}
  .intro-bg{position:absolute; inset:0; background:url('introscreen.png') center/cover no-repeat #000;}
  /* On tall/narrow devices, show whole image instead of cropping */
  @media (max-aspect-ratio: 3/4) {
    .intro-bg{ background-size:contain; background-position:center center; }
  }

  .scene-container{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:#4a7ba7; }
  .scene-bg{ width:100%; height:100%; position:relative; display:flex; align-items:center; justify-content:center; perspective:900px; }
  .scene-bg img{ width:100%; height:100%; object-fit:cover; display:block; user-select:none; -webkit-user-drag:none; }

  .door-container{ position:absolute; left:50%; top:52%; width:140px; height:180px; transform:translate(-50%, -50%); cursor:pointer; z-index:50; }
  .door-left, .door-right{
    position:absolute; width:50%; height:100%;
    background:#3d2418; border:3px solid #2d1810;
    transition:transform 0.8s cubic-bezier(0.68,-0.55,0.265,1.55);
    box-shadow: inset 0 0 20px rgba(0,0,0,0.4), 0 0 10px rgba(0,0,0,0.8);
    backface-visibility:hidden; transform-style:preserve-3d;
  }
  .door-left{ left:0;  transform-origin:left center;  border-right:2px solid #1a0e08; }
  .door-right{right:0;  transform-origin:right center; border-left: 2px solid #1a0e08; }
  .door-panel{ position:absolute; background:#2d1810; border:2px solid #1a0e08; box-shadow: inset 2px 2px 4px rgba(0,0,0,0.4), inset -1px -1px 2px rgba(61,36,24,0.3); }
  .door-left .panel-top{   width:65%; height:22%; top:15%; left:17.5%;}
  .door-left .panel-mid{   width:65%; height:22%; top:41%; left:17.5%;}
  .door-left .panel-bottom{width:65%; height:22%; top:67%; left:17.5%;}
  .door-right .panel-top{   width:65%; height:22%; top:15%; right:17.5%;}
  .door-right .panel-mid{   width:65%; height:22%; top:41%; right:17.5%;}
  .door-right .panel-bottom{width:65%; height:22%; top:67%; right:17.5%;}

  .door-open .door-left{ transform:rotateY(85deg); }
  .door-open .door-right{ transform:rotateY(-85deg); }

  .chunklet-container{ position:absolute; transform:translate(-50%, -30px); opacity:0; transition:opacity 0.3s; z-index:60; pointer-events:none; }
  .chunklet-container.active{ opacity:1; }
  .chunklet-wrap{ position:relative; width:calc(100px*var(--figure-scale)); height:calc(130px*var(--figure-scale)); display:flex; align-items:flex-end; justify-content:center; }
  .chunklet-img{ width:calc(90px*var(--figure-scale)); max-width:100%; user-select:none; -webkit-user-drag:none; filter:drop-shadow(0 8px 16px rgba(0,0,0,.6)); image-rendering:-webkit-optimize-contrast; }

  .ground-shadow{ position:absolute; left:50%; bottom:-2px; width:88px; height:18px; transform:translateX(-50%) scale(0.6); background:radial-gradient(ellipse at center, rgba(0,0,0,.45) 0%, rgba(0,0,0,.25) 40%, rgba(0,0,0,0) 70%); filter:blur(2px); opacity:0; pointer-events:none; }

  .mouth-overlay{ position:absolute; top:var(--mouth-top); left:var(--mouth-left); width:var(--mouth-w); height:var(--mouth-h); transform:translate(-50%,-50%); display:flex; align-items:center; justify-content:center; pointer-events:none; }
  .mouth-overlay svg{width:100%;height:100%}
  #mouth{transform-origin:50% 50%; transform:scale(1, var(--mouth-scale-0))}

  /* Eyes overlay */
  .eyes-overlay{ position:absolute; top:var(--eye-top); left:50%; transform:translate(-50%,-50%); width:0; height:0; pointer-events:none; }
  .eye-dot{ position:absolute; top:0; width:var(--eye-size); height:var(--eye-size); border-radius:50%; background:#000; transform:translate(-50%,-50%); }
  .eye-left{ left:calc(-1 * var(--eye-gap) / 2); }
  .eye-right{ left:calc(var(--eye-gap) / 2); }
  .eye-dot.blink { transform:translate(-50%,-50%) scaleY(0.15); }

  /* Bubble */
  .output-container{ position:fixed; left:50%; transform:translateX(-50%); width:auto; max-width:90vw; z-index:40; opacity:0; transition:opacity 0.35s; pointer-events:none; top:var(--output-top-fallback); text-align:center; }
  .output-container.active{ opacity:1; }
  .bubble-wrap{ position:relative; display:inline-block; }
  .speech-bubble{ position:relative; background:#fff; border:6px solid #000; border-radius:32px; padding:18px 26px 18px 22px; color:#111; box-shadow:0 6px 0 #000, 0 14px 30px rgba(0,0,0,.35); display:inline-block; max-width:86vw; }
  .bubble-tail{ position:absolute; bottom:-2px; left:var(--tail-x); transform:translate(-50%, 100%); width:44px; height:28px; pointer-events:none; }
  .output{ font-family:"Emilys Candy", Rubik, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; text-transform:uppercase; font-weight:400; font-size:clamp(22px, 2.4vw, 36px); line-height:1.04; letter-spacing:-0.06em; word-spacing:-0.04em; color:#111; margin:0; white-space:pre-wrap; text-align:center; }
  .cursor{ display:inline-block; width:.5ch; height:1.05em; background:#111; vertical-align:text-bottom; animation:blink 1s steps(1,end) infinite; border-radius:2px;}
  @keyframes blink{0%,55%{opacity:1}56%,100%{opacity:0}}
  .typing .cursor{animation:none}
  .output .work-tag{ opacity:.95; text-transform:uppercase; margin-left:.6em; font-size:.72em; letter-spacing:-0.06em; word-spacing:-0.04em; color:#333; display:block; margin-top:12px; }

  /* Entrance */
  @keyframes emergePop{0%{transform:translate(-50%,-60px) scale(.86,.92) rotate(-3deg); opacity:0; filter:brightness(.85);}40%{transform:translate(-50%,-28px) scale(1.06,.94) rotate(-2deg); opacity:1;}60%{transform:translate(-50%,-18px) scale(.96,1.04) rotate(2deg);}100%{transform:translate(-50%,-12px) scale(1,1) rotate(0deg);}}
  @keyframes waddleDown{0%{transform:translate(-50%,-12px)}10%{transform:translate(-50%,0)}20%{transform:translate(-50%,10px)}30%{transform:translate(-50%,20px)}40%{transform:translate(-50%,30px)}55%{transform:translate(-50%,45px)}70%{transform:translate(-50%,58px)}85%{transform:translate(-50%,66px) scale(1.02,.98)}100%{transform:translate(-50%,70px)}}
  @keyframes shadowEmerge{0%{opacity:0; transform:translateX(-50%) scale(0.4);}60%{opacity:.55; transform:translateX(-50%) scale(0.75);}100%{opacity:.65; transform:translateX(-50%) scale(0.85);}}
  @keyframes shadowWaddle{0%{opacity:.65; transform:translateX(-50%) scale(0.85);}25%{opacity:.70; transform:translateX(-50%) scale(0.95);}50%{opacity:.60; transform:translateX(-50%) scale(0.88);}75%{opacity:.72; transform:translateX(-50%) scale(1.00);}100%{opacity:.68; transform:translateX(-50%) scale(1.05);}}
  .chunklet-container.emerge{animation:emergePop .7s cubic-bezier(.22,1,.36,1) forwards;}
  .chunklet-container.waddle{animation:waddleDown 2.4s cubic-bezier(.22,1,.36,1) forwards;}
  .chunklet-container.emerge .ground-shadow{animation:shadowEmerge .7s ease-out forwards;}
  .chunklet-container.waddle .ground-shadow{animation:shadowWaddle 2.4s ease-out forwards;}

  /* Context card */
  .context-container{ position:fixed; left:50%; transform:translateX(-50%); top:12px; z-index:70; pointer-events:none; opacity:0; transition:opacity .35s ease; max-width:min(700px, 92vw); }
  .context-container.active{ opacity:1; }
  .tweet-card{
    background:#0f172a; color:#e5e7eb;
    border:1px solid rgba(255,255,255,.08);
    border-radius:14px; padding:14px 16px;
    box-shadow:0 8px 28px rgba(0,0,0,.35);
    font: 400 15px/1.45 "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  }
  .tweet-text{ text-transform:lowercase; letter-spacing:.01em; }

  .cal-hud{ position:fixed; left:8px; bottom:8px; font:12px/1.3 Rubik, ui-monospace, Menlo, Consolas, monospace; background:rgba(0,0,0,.6); color:#0ff; padding:8px 10px; border:1px solid rgba(0,255,255,.35); border-radius:6px; pointer-events:none; opacity:0; transition:opacity .15s; white-space:pre; z-index:100; }
  .cal-hud.on{ opacity:1; }

  /* PHONE LAYOUT TUNE-UP */
  @media (max-width: 600px) {
    :root{
      --figure-scale:.78;
      --mouth-w:14px;
      --mouth-h:14px;
      --mouth-top:38%;
      --mouth-left:49%;

      --eye-top:33.6%;
      --eye-gap:14px;
      --eye-size:3.2px;

      --bubble-gap:12px;
    }

    .intro-bg{ background-size:contain; background-position:center center; }

    .context-container{ top:6px; max-width:94vw; }
    .tweet-card{ padding:10px 12px; font-size:13px; line-height:1.45; }

    .output-container{ max-width:94vw; }
    .speech-bubble{ border-width:4px; border-radius:24px; padding:12px 14px; }
    .output{ font-size:clamp(16px, 4.4vw, 22px); letter-spacing:-0.04em; }
    .bubble-tail{ width:36px; height:24px; }
  }
</style>
</head>
<body>

<div class="intro-overlay" id="intro">
  <div class="intro-bg" aria-hidden="true"></div>
</div>

<audio id="clickSnd" src="click.mp3" preload="auto"></audio>

<div class="scene-container" id="gameRoot" aria-hidden="true">
  <div class="scene-bg">
    <img src="skullbones.png" alt="Scene background" />

    <div class="door-container" id="doorTrigger" aria-label="Open the door" role="button" tabindex="0">
      <div class="door-left">
        <div class="door-panel panel-top"></div>
        <div class="door-panel panel-mid"></div>
        <div class="door-panel panel-bottom"></div>
      </div>
      <div class="door-right">
        <div class="door-panel panel-top"></div>
        <div class="door-panel panel-mid"></div>
        <div class="door-panel panel-bottom"></div>
      </div>
    </div>

    <div class="chunklet-container" id="chunkletContainer" aria-hidden="true">
      <div class="chunklet-wrap">
        <img src="littleboytalk.png" alt="Chubby Chunklet" class="chunklet-img" />
        <div class="eyes-overlay" id="eyes">
          <div class="eye-dot eye-left"></div>
          <div class="eye-dot eye-right"></div>
        </div>
        <div class="mouth-overlay">
          <svg viewBox="0 0 100 100" aria-hidden="true">
            <ellipse id="mouth" cx="50" cy="50" rx="26" ry="24" fill="#111"/>
          </svg>
        </div>
        <div class="ground-shadow"></div>
      </div>
    </div>
  </div>
</div>

<div class="output-container" id="outputContainer" aria-live="polite">
  <div class="bubble-wrap">
    <div class="speech-bubble" id="bubble">
      <div class="output" id="output">
        <span id="typed"></span><span id="cursor" class="cursor"></span>
      </div>
    </div>
    <svg class="bubble-tail" id="bubbleTail" viewBox="0 0 44 28" preserveAspectRatio="xMidYMid meet" aria-hidden="true">
      <path d="M4,2 C 14,20 30,20 40,2" fill="#fff" stroke="#000" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  </div>
</div>

<!-- tweet-style context -->
<div class="context-container" id="ctx">
  <div class="tweet-card">
    <div class="tweet-text" id="ctxText"></div>
  </div>
</div>

<div class="cal-hud" id="calHud"></div>

<script>
(() => {
  const css = getComputedStyle(document.documentElement);
  const ENDPOINT = (css.getPropertyValue('--endpoint') || '').trim() ||
    'https://pu30nzsu59.execute-api.us-east-1.amazonaws.com/dev/chunklet';

  const IS_PHONE = window.matchMedia('(max-width: 600px)').matches;

  // Primary tries for TTS + context; on phones also ask for "simple" context.
  const QUERY_PRIMARY  = IS_PHONE
    ? '?style=canon&modern=0&accent=scottish&context=1&ctx_simple=1&tts=1'
    : '?style=canon&modern=0&accent=scottish&context=1&tts=1';
  const QUERY_FALLBACK = '?style=canon&modern=0&accent=scottish&context=0&tts=0';

  const CHAR_MS  = parseInt(css.getPropertyValue('--char-ms'),10) || 20;

  const DOOR_SWING_MS = 800, EMERGE_MS = 700, WADDLE_MS = 2400;
  const SHOW_CTX_AFTER_MS = 800;
  const BUBBLE_LINGER_MS  = 50000;
  const CTX_LINGER_MS     = 50000;

  const BLINK_MIN = 2600, BLINK_MAX = 5400;

  const intro = document.getElementById('intro');
  const gameRoot = document.getElementById('gameRoot');

  const doorTrigger       = document.getElementById('doorTrigger');
  const chunkletContainer = document.getElementById('chunkletContainer');
  const outputContainer   = document.getElementById('outputContainer');
  const typed             = document.getElementById('typed');
  const cursor            = document.getElementById('cursor');
  const mouth             = document.getElementById('mouth');
  const output            = document.getElementById('output');
  const clickSnd          = document.getElementById('clickSnd');

  const eyesWrap = document.getElementById('eyes');
  const eyeL = eyesWrap.querySelector('.eye-left');
  const eyeR = eyesWrap.querySelector('.eye-right');

  const ctxWrap = document.getElementById('ctx');
  const ctxText = document.getElementById('ctxText');

  const bgImg   = document.querySelector('.scene-bg img');
  const hostEl  = document.querySelector('.scene-bg');

  let busy=false, doorOpen=false;
  let audioCtx,currentSource,audioEl,mediaSource,analyser,timeData;
  let raf,animating=false,tagPlaying=false;
  let currentObjectURL=null;
  let blinkTO=null;

  const sanitize = txt=>{ txt=(txt||'').trim().replace(/!+$/,'').replace(/\s+/g,' '); return /[.?!]$/.test(txt)?txt:txt+'.'; };

  /* ---- AUDIO UNLOCK ---- */
  let audioUnlocked = false;
  function unlockAudio(){
    if (audioUnlocked) return;
    try{
      ensureCtx();
      if(audioCtx && audioCtx.state==='suspended') audioCtx.resume();
      attachAnalyserToMediaElement();
      // 20ms silent beep to satisfy gesture requirement
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      gain.gain.value = 0;
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.02);
      audioUnlocked = true;
    }catch(_){}
  }

  function typeOut(text, done){
    if(!outputContainer.classList.contains('active')){
      outputContainer.classList.add('active');
    }
    typed.textContent='';
    output.classList.add('typing');
    (function loop(i=0){
      typed.textContent = text.slice(0,i);
      placeBubble();
      if(i<text.length){
        setTimeout(()=>loop(i+1), CHAR_MS + ((i%7)?0:Math.random()*10));
      }else{
        output.classList.remove('typing');
        placeBubble();
        done && done();
      }
    })();
  }

  const SY=[0.07,0.55,1.10,1.70,2.30], SX=[1.00,1.01,1.02,1.02,1.03];
  const THRESH_UP=[0.030,0.060,0.100,0.160], HYST_DELTA=0.018;
  const THRESH_DOWN=THRESH_UP.map(t=>Math.max(0,t-HYST_DELTA));
  const GATE_FLOOR=0.010, CLOSE_GRACE_MS=20;
  let level=0,lastChange=0;

  function ensureCtx(){ if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); if(audioCtx.state==='suspended') audioCtx.resume(); }
  function ensureAnalyser(){ ensureCtx(); if(!analyser){ analyser=audioCtx.createAnalyser(); analyser.fftSize=256; analyser.smoothingTimeConstant=0.0; timeData=new Float32Array(analyser.fftSize);} }
  function attachAnalyserToMediaElement(){
    ensureAnalyser();
    if(!audioEl){
      audioEl=document.createElement('audio');
      audioEl.style.position='absolute'; audioEl.style.left='-9999px';
      audioEl.setAttribute('playsinline',''); audioEl.setAttribute('webkit-playsinline','');
      audioEl.muted = false;
      document.body.appendChild(audioEl);
    }
    if(!mediaSource && audioCtx && audioEl){
      try{ mediaSource=audioCtx.createMediaElementSource(audioEl); mediaSource.connect(analyser); analyser.connect(audioCtx.destination); }
      catch(e){ console.warn('media element source failed', e); }
    }
  }
  function rmsLevel(){ if(!analyser||!timeData) return 0; analyser.getFloatTimeDomainData(timeData); let s=0; for(let i=0;i<timeData.length;i++){s+=timeData[i]*timeData[i]} let r=Math.sqrt(s/timeData.length); return r<GATE_FLOOR?0:r; }
  function setLevel(n){ n=Math.max(0,Math.min(4,n|0)); if(n===level) return; level=n; mouth.style.transform=`scale(${SX[level]}, ${SY[level]})`; lastChange=performance.now(); }
  function setClosed(){ setLevel(0); }
  function startMouth(){ if(animating) return; animating=true; raf=requestAnimationFrame(tick); }
  function stopMouth(){ animating=false; cancelAnimationFrame(raf); setClosed(); }
  function tick(){
    if(!animating) return; raf=requestAnimationFrame(tick);
    const active=!!currentSource||tagPlaying, now=performance.now();
    if(active){
      if(analyser && (currentSource || (tagPlaying && mediaSource))){
        const e=rmsLevel();
        let target=level;
        while(target<4 && e>=THRESH_UP[target]) target++;
        while(target>0 && e<THRESH_DOWN[target-1]) target--;
        if(target<level && (now-lastChange)<CLOSE_GRACE_MS) target=level;
        setLevel(target);
        const speakScale = 1 - Math.min(0.22, level*0.04);
        eyeL.style.transform = `translate(-50%,-50%) scaleY(${speakScale})`;
        eyeR.style.transform = `translate(-50%,-50%) scaleY(${speakScale})`;
      }else{ const t=(now/1000); const phase=((t*15)|0)%5; setLevel([1,2,3,2,1][phase]); }
      return;
    }
    const t=(now/1000); const phase=((t*13)|0)%4; const rand=Math.random();
    setLevel(phase===0?0:phase===1?(rand<.7?1:2):phase===2?(rand<.6?2:3):(rand<.5?3:4));
  }

  const DOOR={
    get x(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--door-x'))||0.5; },
    get y(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--door-y'))||0.55; },
    get w(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--door-w'))||0.10; },
    get h(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--door-h'))||0.25; }
  };

  function positionDoorAndChunklet(){
    const hostRect=hostEl.getBoundingClientRect();
    const natW=bgImg.naturalWidth, natH=bgImg.naturalHeight;

    const scale = (natW&&natH) ? Math.max(hostRect.width/natW, hostRect.height/natH) : 1;
    const dispW = (natW||hostRect.width)*scale;
    const dispH = (natH||hostRect.height)*scale;
    const offsetX=(hostRect.width-dispW)/2, offsetY=(hostRect.height-dispH)/2;

    const cx = hostRect.left + offsetX + dispW*DOOR.x;
    const cy = hostRect.top  + offsetY + dispH*DOOR.y;
    const dw = dispW*DOOR.w, dh = dispH*DOOR.h;

    Object.assign(doorTrigger.style, { left:(cx-hostRect.left)+'px', top:(cy-hostRect.top)+'px', width:dw+'px', height:dh+'px' });

    const exitY = cy + dh*0.35;
    Object.assign(chunkletContainer.style, { left:(cx-hostRect.left)+'px', top:(exitY-hostRect.top)+'px', transform:'translate(-50%,-30px)' });

    placeBubble();
  }

  function placeBubble(){
    const cardRect = outputContainer.getBoundingClientRect();
    const guyRect  = chunkletContainer.getBoundingClientRect();
    if(!(cardRect.width && guyRect.width)) return;

    const desiredBottom = Math.max(8, guyRect.top - parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--bubble-gap')));
    let newTop = Math.max(8, Math.round(desiredBottom - cardRect.height));

    // If context is showing, keep a gap below it
    if (ctxWrap.classList.contains('active')) {
      const ctxRect = ctxWrap.getBoundingClientRect();
      const minTop = Math.round(ctxRect.bottom + 12);
      if (newTop < minTop) newTop = minTop;
    }

    outputContainer.style.top = newTop + 'px';

    const cardLeft = cardRect.left;
    const tailPx = (guyRect.left + guyRect.width/2) - cardLeft;
    const tailPct = Math.max(8, Math.min(92, tailPx / cardRect.width * 100));
    outputContainer.style.setProperty('--tail-x', tailPct + '%');
  }

  new ResizeObserver(()=>placeBubble()).observe(outputContainer);
  function onReadyToPosition(){
    positionDoorAndChunklet();
    setTimeout(positionDoorAndChunklet, 50);
    setTimeout(positionDoorAndChunklet, 250);
  }
  if(bgImg.complete) onReadyToPosition(); else bgImg.addEventListener('load', onReadyToPosition);
  window.addEventListener('resize', positionDoorAndChunklet);
  window.addEventListener('orientationchange', positionDoorAndChunklet);

  function openDoor(){
    if(doorOpen) return;
    positionDoorAndChunklet();
    doorOpen=true; doorTrigger.classList.add('door-open');

    setTimeout(()=>{
      chunkletContainer.classList.add('active','emerge');
      setTimeout(()=>{
        chunkletContainer.classList.remove('emerge');
        chunkletContainer.classList.add('waddle');
        setTimeout(()=>{ placeBubble(); }, WADDLE_MS);
      }, EMERGE_MS);
    }, DOOR_SWING_MS);
  }
  function closeDoor(){
    if(!doorOpen) return; doorOpen=false;
    chunkletContainer.classList.remove('active','emerge','waddle');
    outputContainer.classList.remove('active');
    ctxWrap.classList.remove('active');
    clearWorkTag();
    setTimeout(()=>{ doorTrigger.classList.remove('door-open'); busy=false; }, 500);
  }

  function scheduleBlink(){
    clearTimeout(blinkTO);
    const ms = Math.round(BLINK_MIN + Math.random()*(BLINK_MAX-BLINK_MIN));
    blinkTO = setTimeout(()=>{
      eyeL.classList.add('blink'); eyeR.classList.add('blink');
      setTimeout(()=>{ eyeL.classList.remove('blink'); eyeR.classList.remove('blink'); scheduleBlink(); }, 120);
    }, ms);
  }

  async function playAudio(b64,onEnd){
    try{
      ensureCtx(); ensureAnalyser(); attachAnalyserToMediaElement();
      const bin=Uint8Array.from(atob(b64.split(',')[1]), c=>c.charCodeAt(0));
      const blob=new Blob([bin], {type:'audio/mp3'});
      if(!audioEl){ audioEl=document.createElement('audio'); audioEl.hidden=true; document.body.appendChild(audioEl); }
      if(currentObjectURL){ URL.revokeObjectURL(currentObjectURL); currentObjectURL=null; }
      currentObjectURL=URL.createObjectURL(blob); audioEl.src=currentObjectURL;

      audioEl.onplay = ()=>{ setClosed(); startMouth(); tagPlaying=true; };
      audioEl.onended= ()=>{ tagPlaying=false; stopMouth(); if(currentObjectURL){ URL.revokeObjectURL(currentObjectURL); currentObjectURL=null; } onEnd&&onEnd(); };
      audioEl.onerror = (e)=>{ console.warn('Audio element error', e); };

      // iOS sometimes needs a resume right before play
      if (audioCtx && audioCtx.state === 'suspended') { try { await audioCtx.resume(); } catch(_){} }

      await audioEl.play();
    }catch(err){
      console.warn('Audio play blocked/failed; fallback mouth only', err);
      startMouth(); const approx=Math.min(7, Math.max(2.2, (typed.textContent||'').length/16));
      setTimeout(()=>{ stopMouth(); onEnd&&onEnd(); }, (approx+0.2)*1000);
    }
  }
  function stopAudio(){
    if(currentSource){ try{currentSource.stop();}catch(_){ } try{currentSource.disconnect();}catch(_){ } currentSource=null; }
    if(audioEl){ try{ audioEl.pause(); audioEl.currentTime=0; }catch(_){ } }
    if(currentObjectURL){ URL.revokeObjectURL(currentObjectURL); currentObjectURL=null; }
    tagPlaying=false;
  }

  function showWork(work, author){
    const old = document.querySelector('#output .work-tag'); if(old) old.remove();
    if(!work && !author) return;
    const span=document.createElement('span'); span.className='work-tag';
    span.textContent='— '+[work,author].filter(Boolean).join(' · ');
    document.getElementById('output').appendChild(span);
  }
  function clearWorkTag(){ const old = document.querySelector('#output .work-tag'); if(old) old.remove(); }

  // --- Robust fetch with timeout and fallback ---
  function fetchJSONWithTimeout(url, timeoutMs){
    const ctrl = new AbortController();
    const id = setTimeout(()=>ctrl.abort(), timeoutMs);
    return fetch(url, { cache:'no-store', signal: ctrl.signal })
      .finally(()=> clearTimeout(id));
  }

  async function fetchLine(){
    try{
      const res = await fetchJSONWithTimeout(ENDPOINT + QUERY_PRIMARY, IS_PHONE ? 14000 : 12000);
      if(!res.ok) throw new Error('HTTP '+res.status);
      return await res.json();
    }catch(err){
      console.warn('Primary fetch failed, falling back to fast line:', err);
      const res2 = await fetchJSONWithTimeout(ENDPOINT + QUERY_FALLBACK, 6000);
      if(!res2.ok) throw new Error('HTTP '+res2.status);
      const data = await res2.json();
      return { ...data, context: null, audioBase64: null, timings: data.timings||[] };
    }
  }

  function startGame(){
    unlockAudio();            // unlock on first tap/keypress
    if(!intro) return;
    scheduleBlink();

    intro.style.transition='opacity .28s ease';
    intro.style.opacity='0';
    setTimeout(()=>{ intro.remove(); gameRoot.removeAttribute('aria-hidden'); }, 280);
  }
  intro.addEventListener('pointerdown', startGame, {passive:true});
  intro.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ startGame(); }});

  function summon(){
    unlockAudio();            // also unlock here
    if(busy) return;
    try{ clickSnd.currentTime=0; clickSnd.play(); }catch(_){}
    busy=true;
    ctxWrap.classList.remove('active');
    stopAudio(); clearWorkTag();
    openDoor();

    (async ()=>{
      try{
        await new Promise(r=>setTimeout(r, DOOR_SWING_MS + EMERGE_MS + WADDLE_MS));
        const data = await fetchLine();

        const work = data.work || null, author = data.author || null;
        const text = sanitize(data.text);
        const ctx   = (data.context && (data.context.summary||'').trim()) || '';

        typeOut(text, async ()=>{
          const onEnd = ()=>{
            showWork(work, author);
            placeBubble();

            if(ctx){
              setTimeout(()=>{
                ctxText.textContent = ctx;
                ctxWrap.classList.add('active');
                placeBubble(); // reflow bubble under context
              }, SHOW_CTX_AFTER_MS);

              setTimeout(()=>{
                ctxWrap.classList.remove('active');
                outputContainer.classList.remove('active');
                clearWorkTag();
                setTimeout(closeDoor, 500);
              }, Math.max(CTX_LINGER_MS, BUBBLE_LINGER_MS - SHOW_CTX_AFTER_MS));
            }else{
              setTimeout(()=>{
                outputContainer.classList.remove('active');
                clearWorkTag();
                setTimeout(closeDoor, 500);
              }, BUBBLE_LINGER_MS);
            }
          };

          if(data.audioBase64){ await playAudio(data.audioBase64, onEnd); }
          else { startMouth(); const approx=Math.min(7, Math.max(2.2, text.length/16)); setTimeout(()=>{ stopMouth(); onEnd(); }, (approx+0.2)*1000); }
        });

      }catch(e){
        console.error(e);
        if(!outputContainer.classList.contains('active')) outputContainer.classList.add('active');
        typed.textContent='the chunklet needs to use his noodle. try again.';
        setTimeout(()=>{ outputContainer.classList.remove('active'); closeDoor(); }, 1800);
      }
    })();
  }

  doorTrigger.addEventListener('click', summon);
  doorTrigger.addEventListener('keydown', e=>{ if(e.key===' '||e.key==='Enter'){ e.preventDefault(); summon(); } });

  // calibration (unchanged)
  const calHud=document.getElementById('calHud'); let calOn=false; const STORAGE_KEY='cc_vars';
  function getVar(name,fallback){ const v=parseFloat(getComputedStyle(document.documentElement).getPropertyValue(name)); return isNaN(v)?(fallback??0):v; }
  function setVar(name,value){ document.documentElement.style.setProperty(name,String(value)); persistVars(); positionDoorAndChunklet(); updateHud(); }
  function persistVars(){
    const data={ door_x:getVar('--door-x'), door_y:getVar('--door-y'), door_w:getVar('--door-w'), door_h:getVar('--door-h'),
      mouth_top:getComputedStyle(document.documentElement).getPropertyValue('--mouth-top'),
      mouth_left:getComputedStyle(document.documentElement).getPropertyValue('--mouth-left'),
      eye_top:getComputedStyle(document.documentElement).getPropertyValue('--eye-top'),
      eye_gap:getComputedStyle(document.documentElement).getPropertyValue('--eye-gap'),
      eye_size:getComputedStyle(document.documentElement).getPropertyValue('--eye-size') };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  }
  function loadVars(){
    try{
      const raw=localStorage.getItem(STORAGE_KEY); if(!raw) return;
      const d=JSON.parse(raw);
      if(d.door_x) document.documentElement.style.setProperty('--door-x', d.door_x);
      if(d.door_y) document.documentElement.style.setProperty('--door-y', d.door_y);
      if(d.door_w) document.documentElement.style.setProperty('--door-w', d.door_w);
      if(d.door_h) document.documentElement.style.setProperty('--door-h', d.door_h);
      if(d.mouth_top)  document.documentElement.style.setProperty('--mouth-top', d.mouth_top);
      if(d.mouth_left) document.documentElement.style.setProperty('--mouth-left', d.mouth_left);
      if(d.eye_top)  document.documentElement.style.setProperty('--eye-top', d.eye_top);
      if(d.eye_gap)  document.documentElement.style.setProperty('--eye-gap', d.eye_gap);
      if(d.eye_size) document.documentElement.style.setProperty('--eye-size', d.eye_size);
    }catch(_){}
  }
  function updateHud(){
    if(!calOn) return;
    const door={ x:getVar('--door-x').toFixed(3), y:getVar('--door-y').toFixed(3), w:getVar('--door-w').toFixed(3), h:getVar('--door-h').toFixed(3) };
    const mTop=getComputedStyle(document.documentElement).getPropertyValue('--mouth-top').trim();
    const mLeft=getComputedStyle(document.documentElement).getPropertyValue('--mouth-left').trim();
    const eTop=getComputedStyle(document.documentElement).getPropertyValue('--eye-top').trim();
    const eGap=getComputedStyle(document.documentElement).getPropertyValue('--eye-gap').trim();
    const eSize=getComputedStyle(document.documentElement).getPropertyValue('--eye-size').trim();
    calHud.textContent=
`CALIBRATION — Shift=fine
Door  x:${door.x}  y:${door.y}  w:${door.w}  h:${door.h}
Mouth top:${mTop}  left:${mLeft}
Eyes top:${eTop}  gap:${eGap}  size:${eSize}
C=toggle  R=reset`;
  }
  function toggleCal(){ calOn=!calOn; calHud.classList.toggle('on', calOn); updateHud(); }
  function resetSaved(){ localStorage.removeItem(STORAGE_KEY); location.reload(); }
  loadVars();
  window.addEventListener('keydown', (e)=>{
    if(e.key==='c'||e.key==='C'){ toggleCal(); return; }
    if(!calOn) return;
    if(e.key==='r'||e.key==='R'){ resetSaved(); return; }
  });

  positionDoorAndChunklet();
})();
</script>
</body>
</html>
