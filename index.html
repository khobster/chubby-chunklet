<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>chubby chunklet</title>
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />

<link rel="icon" type="image/png" href="favicon.png" />
<link rel="apple-touch-icon" href="favicon.png" />

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
<link href="https://fonts.googleapis.com/css2?family=Emilys+Candy&family=Rubik:wght@400;500;700&family=DM+Sans:wght@400;600;700&display=swap" rel="stylesheet" />

<style>
  :root{
    --endpoint: https://pu30nzsu59.execute-api.us-east-1.amazonaws.com/dev/chunklet;

    /* Figure + face */
    --figure-scale: 1.08;
    --mouth-top:39%;
    --mouth-left:49%;
    --mouth-w:20px;
    --mouth-h:20px;
    --mouth-scale-0:.08;

    --eye-top:34.2%;
    --eye-gap:18px;
    --eye-size:4px;

    --char-ms:18;

    /* Door hotspot (in image-relative coords) */
    --door-x: 0.472;
    --door-y: 0.579;
    --door-w: 0.099;
    --door-h: 0.248;

    --bubble-gap: 18px;
    --tail-x: 50%;
  }

  *{box-sizing:border-box}
  html,body{
    margin:0;padding:0;
    font-family:Rubik, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    background:#000;color:#fff; -webkit-font-smoothing:antialiased;
    overflow:hidden; height:100%; width:100%;
  }

  /* INTRO */
  .intro-overlay{position:fixed; inset:0; z-index:9999; display:flex; align-items:center; justify-content:center; background:#000; cursor:pointer;}
  .intro-bg{position:absolute; inset:0; background:url('introscreen.png') center/cover no-repeat #000;}
  @media (max-aspect-ratio: 3/4) { .intro-bg{ background-size:contain; background-position:center center; } }

  /* Scene */
  .scene-container{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:#4a7ba7; }
  .scene-bg{ width:100%; height:100%; position:relative; display:flex; align-items:center; justify-content:center; perspective:900px; }
  .scene-bg img{ width:100%; height:100%; object-fit:cover; display:block; user-select:none; -webkit-user-drag:none; }

  /* Door hotspot */
  .door-container{ position:absolute; left:50%; top:52%; width:140px; height:180px; transform:translate(-50%, -50%); cursor:pointer; z-index:50; }
  .door-left, .door-right{
    position:absolute; width:50%; height:100%;
    background:#3d2418; border:3px solid #2d1810;
    transition:transform 0.8s cubic-bezier(0.68,-0.55,0.265,1.55);
    box-shadow: inset 0 0 20px rgba(0,0,0,0.4), 0 0 10px rgba(0,0,0,0.8);
    backface-visibility:hidden; transform-style:preserve-3d;
  }
  .door-left{ left:0;  transform-origin:left center;  border-right:2px solid #1a0e08; }
  .door-right{right:0;  transform-origin:right center; border-left: 2px solid #1a0e08; }
  .door-panel{ position:absolute; background:#2d1810; border:2px solid #1a0e08; box-shadow: inset 2px 2px 4px rgba(0,0,0,0.4), inset -1px -1px 2px rgba(61,36,24,0.3); }
  .door-left .panel-top{   width:65%; height:22%; top:15%; left:17.5%;}
  .door-left .panel-mid{   width:65%; height:22%; top:41%; left:17.5%;}
  .door-left .panel-bottom{width:65%; height:22%; top:67%; left:17.5%;}
  .door-right .panel-top{   width:65%; height:22%; top:15%; right:17.5%;}
  .door-right .panel-mid{   width:65%; height:22%; top:41%; right:17.5%;}
  .door-right .panel-bottom{width:65%; height:22%; top:67%; right:17.5%;}
  .door-open .door-left{ transform:rotateY(85deg); }
  .door-open .door-right{ transform:rotateY(-85deg); }

  /* Chunklet */
  .chunklet-container{ position:absolute; transform:translate(-50%, -30px); opacity:0; transition:opacity 0.3s; z-index:60; pointer-events:none; }
  .chunklet-container.active{ opacity:1; }
  .chunklet-wrap{ position:relative; width:calc(100px*var(--figure-scale)); height:calc(130px*var(--figure-scale)); display:flex; align-items:flex-end; justify-content:center; }
  .chunklet-img{ width:calc(90px*var(--figure-scale)); max-width:100%; user-select:none; -webkit-user-drag:none; filter:drop-shadow(0 8px 16px rgba(0,0,0,.6)); image-rendering:-webkit-optimize-contrast; }
  .ground-shadow{ position:absolute; left:50%; bottom:-2px; width:88px; height:18px; transform:translateX(-50%) scale(0.6); background:radial-gradient(ellipse at center, rgba(0,0,0,.45) 0%, rgba(0,0,0,.25) 40%, rgba(0,0,0,0) 70%); filter:blur(2px); opacity:0; pointer-events:none; }

  /* Face overlays */
  .mouth-overlay{ position:absolute; top:var(--mouth-top); left:var(--mouth-left); width:var(--mouth-w); height:var(--mouth-h); transform:translate(-50%,-50%); display:flex; align-items:center; justify-content:center; pointer-events:none; z-index:2; }
  .mouth-overlay svg{width:100%;height:100%}
  #mouth{transform-origin:50% 50%; transform:scale(1, var(--mouth-scale-0)); stroke:#000; stroke-width:1.4px;}
  .eyes-overlay{ position:absolute; top:var(--eye-top); left:50%; transform:translate(-50%,-50%); width:0; height:0; pointer-events:none; z-index:2; }
  .eye-dot{ position:absolute; top:0; width:var(--eye-size); height:var(--eye-size); border-radius:50%; background:#000; transform:translate(-50%,-50%); }
  .eye-left{ left:calc(-1 * var(--eye-gap) / 2); }
  .eye-right{ left:calc(var(--eye-gap) / 2); }
  .eye-dot.blink { transform:translate(-50%,-50%) scaleY(0.15); }

  /* Bubble */
  .output-container{ position:fixed; left:50%; transform:translateX(-50%); width:auto; max-width:min(94vw, 760px); z-index:40; opacity:0; transition:opacity 0.35s; pointer-events:none; text-align:center; }
  .output-container.active{ opacity:1; }
  .bubble-wrap{ position:relative; display:inline-block; }
  .speech-bubble{ position:relative; background:#fff; border:6px solid #000; border-radius:32px; padding:18px 26px 18px 22px; color:#111; box-shadow:0 6px 0 #000, 0 14px 30px rgba(0,0,0,.35); display:inline-block; max-width:100%; }
  .bubble-tail{ position:absolute; bottom:-2px; left:var(--tail-x); transform:translate(-50%, 100%); width:44px; height:28px; pointer-events:none; }
  .output{ font-family:"Emilys Candy", Rubik, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; text-transform:uppercase; font-weight:400; font-size:clamp(22px, 2.6vw, 36px); line-height:1.04; letter-spacing:-0.06em; word-spacing:-0.04em; color:#111; margin:0; white-space:pre-wrap; text-align:center; }
  .cursor{ display:inline-block; width:.5ch; height:1.05em; background:#111; vertical-align:text-bottom; border-radius:2px; opacity:0; }
  @keyframes blink{0%,55%{opacity:1}56%,100%{opacity:0}}
  .typing .cursor{ opacity:1; animation:blink 1s steps(1,end) infinite; }
  .output .work-tag{ opacity:.95; text-transform:uppercase; margin-left:.6em; font-size:.72em; letter-spacing:-0.06em; word-spacing:-0.04em; color:#333; display:block; margin-top:12px; }

  /* Entrance animations */
  @keyframes emergePop{0%{transform:translate(-50%,-60px) scale(.86,.92) rotate(-3deg); opacity:0; filter:brightness(.85);}40%{transform:translate(-50%,-28px) scale(1.06,.94) rotate(-2deg); opacity:1;}60%{transform:translate(-50%,-18px) scale(.96,1.04) rotate(2deg);}100%{transform:translate(-50%,-12px) scale(1,1) rotate(0deg);}}
  @keyframes waddleDown{0%{transform:translate(-50%,-12px)}10%{transform:translate(-50%,0)}20%{transform:translate(-50%,10px)}30%{transform:translate(-50%,20px)}40%{transform:translate(-50%,30px)}55%{transform:translate(-50%,45px)}70%{transform:translate(-50%,58px)}85%{transform:translate(-50%,66px) scale(1.02,.98)}100%{transform:translate(-50%,70px)}}
  @keyframes shadowEmerge{0%{opacity:0; transform:translateX(-50%) scale(0.4);}60%{opacity:.55; transform:translateX(-50%) scale(0.75);}100%{opacity:.65; transform:translateX(-50%) scale(0.85);}}
  @keyframes shadowWaddle{0%{opacity:.65; transform:translateX(-50%) scale(0.85);}25%{opacity:.70; transform:translateX(-50%) scale(0.95);}50%{opacity:.60; transform:translateX(-50%) scale(0.88);}75%{opacity:.72; transform:translateX(-50%) scale(1.00);}100%{opacity:.68; transform:translateX(-50%) scale(1.05);}}
  .chunklet-container.emerge{animation:emergePop .7s cubic-bezier(.22,1,.36,1) forwards;}
  .chunklet-container.waddle{animation:waddleDown 2.4s cubic-bezier(.22,1,.36,1) forwards;}
  .chunklet-container.emerge .ground-shadow{animation:shadowEmerge .7s ease-out forwards;}
  .chunklet-container.waddle .ground-shadow{animation:shadowWaddle 2.4s ease-out forwards;}

  /* Context card */
  .context-container{ position:fixed; left:50%; transform:translateX(-50%); top:8px; z-index:70; pointer-events:none; opacity:0; transition:opacity .35s ease; width:calc(100vw - 24px); max-width:760px; padding:0 6px; }
  .context-container.active{ opacity:1; }
  .tweet-card{
    background:#0f172a; color:#e5e7eb;
    border:1px solid rgba(255,255,255,.08);
    border-radius:14px; padding:12px 14px;
    box-shadow:0 8px 28px rgba(0,0,0,.35);
    font: 400 15px/1.45 "DM Sans", system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  }
  .tweet-text{ letter-spacing:.01em; }

  /* Glasses toggle button — fixed near Chunklet, not the bubble */
  .glasses-btn{
    position:fixed;
    z-index:95; /* keep above everything */
    width:64px; height:64px; border:0; background:transparent; padding:0; display:none;
    transform:translate(-50%,-50%);
    pointer-events:auto;
  }
  .glasses-btn img{ width:100%; height:100%; display:block; filter: drop-shadow(0 6px 14px rgba(0,0,0,.45)); }
  .glasses-btn.show{ display:block; }

  /* Mobile (portrait-first) */
  @media (max-width: 600px) {
    :root{
      --figure-scale:.70;
      --mouth-w:16px;
      --mouth-h:16px;
      --mouth-top:38.6%;
      --mouth-left:49%;

      --eye-top:33.8%;
      --eye-gap:14px;
      --eye-size:3.4px;

      --bubble-gap:10px;
    }

    .tweet-card{ padding:10px 12px; font-size:14px; line-height:1.45; }
    .output{ font-size:clamp(17px, 4.7vw, 22px); letter-spacing:-0.045em; }
    .speech-bubble{ border-width:5px; border-radius:26px; padding:12px 14px; }
    .bubble-tail{ width:36px; height:24px; }
    .glasses-btn{ width:58px; height:58px; }
  }
</style>
</head>
<body>

<div class="intro-overlay" id="intro" aria-label="Tap to start">
  <div class="intro-bg" aria-hidden="true"></div>
</div>

<!-- Single persistent audio element for ALL sounds (click + TTS) -->
<audio id="mainPlayer" src="click.mp3" preload="auto" playsinline webkit-playsinline></audio>

<div class="scene-container" id="gameRoot" aria-hidden="true">
  <div class="scene-bg">
    <img src="skullbones.png" alt="Scene background" />

    <div class="door-container" id="doorTrigger" aria-label="Open the door" role="button" tabindex="0">
      <div class="door-left">
        <div class="door-panel panel-top"></div>
        <div class="door-panel panel-mid"></div>
        <div class="door-panel panel-bottom"></div>
      </div>
      <div class="door-right">
        <div class="door-panel panel-top"></div>
        <div class="door-panel panel-mid"></div>
        <div class="door-panel panel-bottom"></div>
      </div>
    </div>

    <div class="chunklet-container" id="chunkletContainer" aria-hidden="true">
      <div class="chunklet-wrap">
        <img src="littleboytalk.png" alt="Chubby Chunklet" class="chunklet-img" />
        <div class="eyes-overlay" id="eyes">
          <div class="eye-dot eye-left"></div>
          <div class="eye-dot eye-right"></div>
        </div>
        <div class="mouth-overlay">
          <svg viewBox="0 0 100 100" aria-hidden="true">
            <ellipse id="mouth" cx="50" cy="50" rx="26" ry="24" fill="#111"/>
          </svg>
        </div>
        <div class="ground-shadow"></div>
      </div>
    </div>
  </div>
</div>

<!-- quote bubble -->
<div class="output-container" id="outputContainer" aria-live="polite">
  <div class="bubble-wrap">
    <div class="speech-bubble" id="bubble">
      <div class="output" id="output">
        <span id="typed"></span><span id="cursor" class="cursor"></span>
      </div>
    </div>
    <svg class="bubble-tail" id="bubbleTail" viewBox="0 0 44 28" preserveAspectRatio="xMidYMid meet" aria-hidden="true">
      <path d="M4,2 C 14,20 30,20 40,2" fill="#fff" stroke="#000" stroke-width="6" stroke-linecap="round" stroke-linejoin="round"/>
    </svg>
  </div>
</div>

<!-- context -->
<div class="context-container" id="ctx">
  <div class="tweet-card">
    <div class="tweet-text" id="ctxText"></div>
  </div>
</div>

<!-- toggle -->
<button id="glassesBtn" class="glasses-btn" aria-label="Toggle note">
  <img src="glasses.png" alt="">
</button>

<div class="cal-hud" id="calHud"></div>

<script>
(() => {
  const css = getComputedStyle(document.documentElement);
  const ENDPOINT = (css.getPropertyValue('--endpoint') || '').trim() ||
    'https://pu30nzsu59.execute-api.us-east-1.amazonaws.com/dev/chunklet';

  const IS_PHONE = window.matchMedia('(max-width: 600px)').matches;

  // Phase 1: fast quote + context (no TTS)
  const QUERY_QUOTE = '?only_quote=1&style=canon&modern=0&context=1';
  const QUERY_QUOTE_FALLBACK = '?style=canon&modern=0&context=0&tts=0';
  // Phase 2: TTS for whatever text we displayed
  const buildTTS = (t)=> `?only_tts=1&accent=scottish&voice=verse&text=${encodeURIComponent(t)}`;

  const CHAR_MS  = parseInt(css.getPropertyValue('--char-ms'),10) || 20;

  const DOOR_SWING_MS = 800, EMERGE_MS = 700, WADDLE_MS = 2400;
  const SHOW_CTX_AFTER_MS = 700;
  const BUBBLE_LINGER_MS  = 50000;
  const CTX_LINGER_MS     = 50000;

  const BLINK_MIN = 2600, BLINK_MAX = 5400;

  const intro = document.getElementById('intro');
  const gameRoot = document.getElementById('gameRoot');

  const doorTrigger       = document.getElementById('doorTrigger');
  const chunkletContainer = document.getElementById('chunkletContainer');
  const outputContainer   = document.getElementById('outputContainer');
  const typed             = document.getElementById('typed');
  const cursor            = document.getElementById('cursor');
  const mouth             = document.getElementById('mouth');
  const output            = document.getElementById('output');

  const mainPlayer        = document.getElementById('mainPlayer');
  mainPlayer.crossOrigin  = 'anonymous';
  const CLICK_MP3         = 'click.mp3';

  mainPlayer.addEventListener('error', () => {
    const el = mainPlayer;
    const code = el.error && el.error.code;
    console.warn('mainPlayer error', code, el.error);
  });

  const eyesWrap = document.getElementById('eyes');
  const eyeL = eyesWrap.querySelector('.eye-left');
  const eyeR = eyesWrap.querySelector('.eye-right');

  const ctxWrap = document.getElementById('ctx');
  const ctxText = document.getElementById('ctxText');

  const bgImg   = document.querySelector('.scene-bg img');
  const hostEl  = document.querySelector('.scene-bg');

  const glassesBtn = document.getElementById('glassesBtn');

  let busy=false, doorOpen=false;
  let audioCtx, mediaSource, analyser, timeData;
  let raf,animating=false,tagPlaying=false;
  let currentObjectURL=null;
  let blinkTO=null;

  // iOS gesture gating
  let primed=false;
  let gestureGuardUntil = 0;

  let currentView = 'quote'; // 'quote' | 'context'
  let lastContextText = '';

  const sanitize = txt=>{ txt=(txt||'').trim().replace(/!+$/,'').replace(/\s+/g,' '); return /[.?!]$/.test(txt)?txt:txt+'.'; };

  /* ---- platform info ---- */
  const isiOS = /iP(hone|od|ad)/.test(navigator.userAgent);
  const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

  /* ---- Web Speech fallback ---- */
  function speakWithWebSpeech(text){
    return new Promise(resolve=>{
      if(!('speechSynthesis' in window)){ resolve(false); return; }

      function doSpeak(){
        const u = new SpeechSynthesisUtterance(text);
        const voices = speechSynthesis.getVoices();
        const pick = voices.find(v=>/en(-|_)GB/i.test(v.lang)) || voices.find(v=>/en(-|_)US/i.test(v.lang)) || voices[0];
        if(pick) u.voice = pick;
        u.rate = 0.95; u.pitch = 1.0; u.volume = 1.0;

        let ended=false;
        u.onend = ()=>{ if(!ended){ ended=true; stopMouth(); resolve(true); } };
        u.onerror = ()=>{ if(!ended){ ended=true; stopMouth(); resolve(false); } };

        startMouth();
        const approx = Math.max(2.4, Math.min(10, text.length/14));
        setTimeout(()=>{ if(!ended){ ended=true; stopMouth(); resolve(true); } }, approx*1000 + 600);

        try{ speechSynthesis.cancel(); speechSynthesis.speak(u); }
        catch(_){ stopMouth(); resolve(false); }
      }

      // Safari sometimes populates voices async
      const voicesNow = speechSynthesis.getVoices();
      if (voicesNow && voicesNow.length){ doSpeak(); }
      else{
        const to = setTimeout(doSpeak, 300);
        speechSynthesis.addEventListener('voiceschanged', ()=>{ clearTimeout(to); doSpeak(); }, { once:true });
      }
    });
  }

  /* ---- AUDIO / ANALYSER ---- */
  function ensureCtx(){ if(!audioCtx) audioCtx=new (window.AudioContext||window.webkitAudioContext)(); if(audioCtx.state==='suspended') audioCtx.resume(); }
  function ensureAnalyser(){ ensureCtx(); if(!analyser){ analyser=audioCtx.createAnalyser(); analyser.fftSize=256; analyser.smoothingTimeConstant=0.0; timeData=new Float32Array(analyser.fftSize);} }

  function attachAnalyserToMediaElement(){
    ensureAnalyser();
    if(!mediaSource && audioCtx && mainPlayer){
      try{
        mediaSource = audioCtx.createMediaElementSource(mainPlayer);
        mediaSource.connect(analyser);
        analyser.connect(audioCtx.destination);
      }catch(e){ console.warn('media element source failed', e); }
    }
  }

  function unlockAudio(){
    try{
      ensureCtx();
      if(audioCtx && audioCtx.state==='suspended') audioCtx.resume();
      attachAnalyserToMediaElement();
      // gesture-safe tiny silent beep
      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();
      gain.gain.value = 0;
      osc.connect(gain).connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + 0.02);
    }catch(_){}
  }

  function typeOut(text, done){
    if(!outputContainer.classList.contains('active')){
      outputContainer.classList.add('active');
    }
    typed.textContent='';
    output.classList.add('typing');
    (function loop(i=0){
      typed.textContent = text.slice(0,i);
      placeBubble(); placeGlasses();
      if(i<text.length){
        setTimeout(()=>loop(i+1), CHAR_MS + ((i%7)?0:Math.random()*10));
      }else{
        output.classList.remove('typing');
        placeBubble(); placeGlasses();
        done && done();
      }
    })();
  }

  // mouth anim thresholds
  const SY=[0.10,0.58,1.12,1.72,2.34], SX=[1.00,1.01,1.02,1.02,1.03];
  const THRESH_UP=[0.030,0.060,0.100,0.160], HYST_DELTA=0.018;
  const THRESH_DOWN=THRESH_UP.map(t=>Math.max(0,t-HYST_DELTA));
  const GATE_FLOOR=0.010, CLOSE_GRACE_MS=20;
  let level=0,lastChange=0;

  function rmsLevel(){ if(!analyser||!timeData) return 0; analyser.getFloatTimeDomainData(timeData); let s=0; for(let i=0;i<timeData.length;i++){s+=timeData[i]*timeData[i]} let r=Math.sqrt(s/timeData.length); return r<GATE_FLOOR?0:r; }
  function setLevel(n){ n=Math.max(0,Math.min(4,n|0)); if(n===level) return; level=n; mouth.style.transform=`scale(${SX[level]}, ${SY[level]})`; lastChange=performance.now(); }
  function setClosed(){ setLevel(0); }
  function startMouth(){ if(animating) return; animating=true; raf=requestAnimationFrame(tick); }
  function stopMouth(){ animating=false; cancelAnimationFrame(raf); setClosed(); }

  function tick(){
    if(!animating) return; raf=requestAnimationFrame(tick);
    if(tagPlaying){
      if(analyser && mediaSource){
        const e=rmsLevel();
        let target=level;
        const now=performance.now();
        while(target<4 && e>=THRESH_UP[target]) target++;
        while(target>0 && e<THRESH_DOWN[target-1]) target--;
        if(target<level && (now-lastChange)<CLOSE_GRACE_MS) target=level;
        setLevel(target);
        const speakScale = 1 - Math.min(0.22, level*0.04);
        eyeL.style.transform = `translate(-50%,-50%) scaleY(${speakScale})`;
        eyeR.style.transform = `translate(-50%,-50%) scaleY(${speakScale})`;
      } else {
        setClosed();
      }
      return;
    }
    setClosed();
  }

  const DOOR={
    get x(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--door-x'))||0.5; },
    get y(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--door-y'))||0.55; },
    get w(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--door-w'))||0.10; },
    get h(){ return parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--door-h'))||0.25; }
  };

  function positionDoorAndChunklet(){
    const hostRect=hostEl.getBoundingClientRect();
    const natW=bgImg.naturalWidth, natH=bgImg.naturalHeight;

    const scale = (natW&&natH) ? Math.max(hostRect.width/natW, hostRect.height/natH) : 1;
    const dispW = (natW||hostRect.width)*scale;
    const dispH = (natH||hostRect.height)*scale;
    const offsetX=(hostRect.width-dispW)/2, offsetY=(hostRect.height-dispH)/2;

    const cx = hostRect.left + offsetX + dispW*DOOR.x;
    const cy = hostRect.top  + offsetY + dispH*DOOR.y;
    const dw = dispW*DOOR.w, dh = dispH*DOOR.h;

    Object.assign(doorTrigger.style, { left:(cx-hostRect.left)+'px', top:(cy-hostRect.top)+'px', width:dw+'px', height:dh+'px' });

    const exitY = cy + dh*0.35;
    Object.assign(chunkletContainer.style, { left:(cx-hostRect.left)+'px', top:(exitY-hostRect.top)+'px', transform:'translate(-50%,-30px)' });

    placeBubble(); placeGlasses();
  }

  function placeBubble(){
    const cardRect = outputContainer.getBoundingClientRect();
    const guyRect  = chunkletContainer.getBoundingClientRect();
    if(!(cardRect.width && guyRect.width)) return;

    const bubbleGap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--bubble-gap'));
    const desiredBottom = Math.max(8, guyRect.top - bubbleGap);
    let newTop = Math.max(8, Math.round(desiredBottom - cardRect.height));

    if (ctxWrap.classList.contains('active')) {
      const ctxRect = ctxWrap.getBoundingClientRect();
      const minTop = Math.round(ctxRect.bottom + 10);
      if (newTop < minTop) newTop = minTop;
    }
    outputContainer.style.top = newTop + 'px';

    const cardLeft = cardRect.left;
    const tailPx = (guyRect.left + guyRect.width/2) - cardLeft;
    const tailPct = Math.max(8, Math.min(92, tailPx / Math.max(1,cardRect.width) * 100));
    outputContainer.style.setProperty('--tail-x', tailPct + '%');
  }

  // GLASSES: fixed near Chunklet + clamped to viewport
  function placeGlasses(){
    const guyRect = chunkletContainer.getBoundingClientRect();
    if(!guyRect.width) return;

    const baseX = guyRect.left + guyRect.width/2 + (IS_PHONE ? 75 : 80);
    const offset = IS_PHONE ? 52 : 58;
    const baseY = Math.min(window.innerHeight - 72, guyRect.bottom + offset);

    const btnW = IS_PHONE ? 58 : 64;
    const btnH = IS_PHONE ? 58 : 64;
    const margin = 8;

    const minX = margin + btnW/2;
    const maxX = window.innerWidth - margin - btnW/2;
    const minY = margin + btnH/2;
    const maxY = window.innerHeight - margin - btnH/2;

    const x = Math.max(minX, Math.min(maxX, baseX));
    const y = Math.max(minY, Math.min(maxY, baseY));

    glassesBtn.style.left = x + 'px';
    glassesBtn.style.top  = y + 'px';
  }

  new ResizeObserver(()=>{ placeBubble(); placeGlasses(); }).observe(outputContainer);
  function onReadyToPosition(){
    positionDoorAndChunklet();
    setTimeout(positionDoorAndChunklet, 50);
    setTimeout(positionDoorAndChunklet, 250);
  }
  if(bgImg.complete) onReadyToPosition(); else bgImg.addEventListener('load', onReadyToPosition);
  window.addEventListener('resize', positionDoorAndChunklet);
  window.addEventListener('orientationchange', positionDoorAndChunklet);

  function openDoor(){
    if(doorOpen) return;
    positionDoorAndChunklet();
    doorOpen=true; doorTrigger.classList.add('door-open');

    setTimeout(()=>{
      chunkletContainer.classList.add('active','emerge');
      setTimeout(()=>{
        chunkletContainer.classList.remove('emerge');
        chunkletContainer.classList.add('waddle');
        setTimeout(()=>{ placeBubble(); placeGlasses(); }, WADDLE_MS);
      }, EMERGE_MS);
    }, DOOR_SWING_MS);
  }
  function closeDoor(){
    if(!doorOpen) return; doorOpen=false;
    chunkletContainer.classList.remove('active','emerge','waddle');
    outputContainer.classList.remove('active');
    ctxWrap.classList.remove('active');
    glassesBtn.classList.remove('show');
    clearWorkTag();
    setTimeout(()=>{ doorTrigger.classList.remove('door-open'); busy=false; }, 500);
  }

  function scheduleBlink(){
    clearTimeout(blinkTO);
    const ms = Math.round(BLINK_MIN + Math.random()*(BLINK_MAX-BLINK_MIN));
    blinkTO = setTimeout(()=>{
      eyeL.classList.add('blink'); eyeR.classList.add('blink');
      setTimeout(()=>{ eyeL.classList.remove('blink'); eyeR.classList.remove('blink'); scheduleBlink(); }, 120);
    }, ms);
  }

  // tiny WAV beep generator (fallback if click.mp3 missing)
  function makeBeepURL(freq=1100, duration=0.07, sampleRate=44100){
    const samples = Math.floor(duration * sampleRate);
    const buffer  = new ArrayBuffer(44 + samples * 2);
    const view    = new DataView(buffer);
    function writeStr(off, s){ for (let i=0;i<s.length;i++) view.setUint8(off+i, s.charCodeAt(i)); }
    writeStr(0, 'RIFF');
    view.setUint32(4, 36 + samples*2, true);
    writeStr(8, 'WAVE');
    writeStr(12,'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, 1,  true);
    view.setUint16(22, 1,  true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * 2, true);
    view.setUint16(32, 2,  true);
    view.setUint16(34, 16, true);
    writeStr(36,'data');
    view.setUint32(40, samples*2, true);
    let offset = 44;
    for (let i=0;i<samples;i++){
      const t = i / sampleRate;
      const amp = Math.sin(2 * Math.PI * freq * t) * 0.35;
      view.setInt16(offset, (amp * 0x7FFF) | 0, true);
      offset += 2;
    }
    const blob = new Blob([buffer], {type:'audio/wav'});
    return URL.createObjectURL(blob);
  }

  async function playClickOrBeep(){
    if(currentObjectURL){ URL.revokeObjectURL(currentObjectURL); currentObjectURL=null; }
    try{
      mainPlayer.src = CLICK_MP3;
      mainPlayer.load();
      mainPlayer.currentTime = 0;
      await mainPlayer.play();
      return true;
    }catch(err){
      console.warn('click.mp3 failed, falling back to beep', err);
      try{
        const beepURL = makeBeepURL(1200, 0.06);
        mainPlayer.src = beepURL;
        mainPlayer.load();
        mainPlayer.currentTime = 0;
        await mainPlayer.play();
        setTimeout(()=>{ try{ URL.revokeObjectURL(beepURL); }catch(_){} }, 2000);
        return true;
      }catch(e2){
        console.warn('Beep fallback also failed', e2);
        return false;
      }
    }
  }

  // Play TTS using the persistent mainPlayer (then analyser drives mouth)
  async function playAudio(b64,onEnd){
    try{
      ensureCtx(); ensureAnalyser(); attachAnalyserToMediaElement();

      const bin=Uint8Array.from(atob(b64.split(',')[1]), c=>c.charCodeAt(0));
      const blob=new Blob([bin], {type:'audio/mpeg'}); // mp3 mime

      if(currentObjectURL){ URL.revokeObjectURL(currentObjectURL); currentObjectURL=null; }

      currentObjectURL=URL.createObjectURL(blob);
      mainPlayer.src=currentObjectURL;
      mainPlayer.load();
      mainPlayer.currentTime = 0;
      mainPlayer.volume = 1;

      mainPlayer.onplay = ()=>{ setClosed(); startMouth(); tagPlaying=true; };
      mainPlayer.onended= ()=>{ tagPlaying=false; stopMouth(); if(currentObjectURL){ URL.revokeObjectURL(currentObjectURL); currentObjectURL=null; } onEnd&&onEnd(); };
      mainPlayer.onerror = (e)=>{ console.warn('Audio element error', e); onEnd&&onEnd(); };

      if (audioCtx && audioCtx.state === 'suspended') { try { await audioCtx.resume(); } catch(_){} }
      await mainPlayer.play();
    }catch(err){
      console.warn('TTS play blocked/failed; using Web Speech fallback', err);
      await speakWithWebSpeech(typed.textContent || '');
      onEnd && onEnd();
    }
  }
  function stopAudio(){
    try{ mainPlayer.pause(); mainPlayer.currentTime=0; }catch(_){}
    if(currentObjectURL){ URL.revokeObjectURL(currentObjectURL); currentObjectURL=null; }
    tagPlaying=false;
  }

  function showWork(work, author){
    const old = document.querySelector('#output .work-tag'); if(old) old.remove();
    if(!work && !author) return;
    const span=document.createElement('span'); span.className='work-tag';
    span.textContent='— '+[work,author].filter(Boolean).join(' · ');
    document.getElementById('output').appendChild(span);
  }
  function clearWorkTag(){ const old = document.querySelector('#output .work-tag'); if(old) old.remove(); }

  // Robust fetch with timeout
  function fetchJSONWithTimeout(url, timeoutMs){
    const ctrl = new AbortController();
    const id = setTimeout(()=>ctrl.abort('timeout'), timeoutMs);
    return fetch(url, { cache:'no-store', signal: ctrl.signal })
      .finally(()=> clearTimeout(id));
  }
  async function safeGetJSON(url, ms){
    try{
      const res = await fetchJSONWithTimeout(url, ms);
      if(!res.ok) throw new Error('HTTP '+res.status);
      return await res.json();
    }catch(err){
      console.warn('safeGetJSON fail:', err);
      return null;
    }
  }
  async function fetchQuote(){
    const first = await safeGetJSON(ENDPOINT + QUERY_QUOTE, IS_PHONE ? 13000 : 9000);
    if (first && first.text) return first;
    const second = await safeGetJSON(ENDPOINT + QUERY_QUOTE_FALLBACK, IS_PHONE ? 10000 : 8000);
    return second;
  }
  async function fetchTTS(text){
    return await safeGetJSON(ENDPOINT + buildTTS(text), IS_PHONE ? 11000 : 9000);
  }

  async function startGame(e){
    if (e){ e.preventDefault(); e.stopPropagation(); }

    unlockAudio();
    attachAnalyserToMediaElement();

    try{
      const ok = await playClickOrBeep();
      primed = ok;
    }catch(_){ primed=false; }

    // Prevent the intro tap from "falling through" to the door
    gestureGuardUntil = performance.now() + 400;

    if(!intro) return;
    scheduleBlink();

    intro.style.transition='opacity .28s ease';
    intro.style.opacity='0';
    setTimeout(()=>{ intro.remove(); gameRoot.removeAttribute('aria-hidden'); }, 280);
  }
  intro.addEventListener('pointerdown', startGame, {passive:false});
  intro.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ startGame(e); }});

  function showQuoteView(){
    ctxWrap.classList.remove('active');
    outputContainer.classList.add('active');
    currentView = 'quote';
    placeBubble(); placeGlasses();
  }
  function showContextView(){
    outputContainer.classList.remove('active');
    ctxWrap.classList.add('active');
    currentView = 'context';
    placeBubble(); placeGlasses();
  }
  function toggleView(){
    if(!lastContextText) return;
    currentView === 'quote' ? showContextView() : showQuoteView();
  }
  glassesBtn.addEventListener('click', toggleView);

  async function summon(ev){
    if (performance.now() < gestureGuardUntil) { ev && ev.preventDefault(); return; }

    unlockAudio();
    if(busy) return;

    // optional click on door
    try{ await playClickOrBeep(); }catch(_){}

    busy=true;
    ctxWrap.classList.remove('active');
    glassesBtn.classList.remove('show');
    stopAudio(); clearWorkTag();
    openDoor();

    (async ()=>{
      try{
        await new Promise(r=>setTimeout(r, DOOR_SWING_MS + EMERGE_MS + WADDLE_MS));

        // Phase 1: fast content
        const data = await fetchQuote();

        if(!data || !data.text){
          const fallback = "um. ahhh... it's the funniest thing, I completely forgot what I was about to say. Let me go back inside, eat a peanut butter cup then please click on the door again and I'll be right back.";
          const text = sanitize(fallback);
          typeOut(text, async ()=>{
            // try MP3 TTS first, then Web Speech
            const tts = await fetchTTS(text);
            if(tts && tts.audioBase64){
              await new Promise(res=>playAudio(tts.audioBase64, res));
            }else{
              await speakWithWebSpeech(text);
            }
            setTimeout(()=>{ outputContainer.classList.remove('active'); clearWorkTag(); setTimeout(closeDoor, 400); }, 400);
          });
          return;
        }

        const work = data.work || null, author = data.author || null;
        const text = sanitize(data.text);
        lastContextText  = (data.context && (data.context.summary||'').trim()) || '';

        // TYPE the quote
        typeOut(text, async ()=>{
          showWork(work, author);
          placeBubble(); placeGlasses();

          if(lastContextText){
            ctxText.textContent = lastContextText;
            glassesBtn.classList.add('show');
            placeGlasses();
          }
        });

        // Phase 2: TTS first; fallback to Web Speech if needed (works on iOS)
        (async ()=>{
          try{
            const tts = await fetchTTS(text);
            if(tts && tts.audioBase64){
              await new Promise(res=>playAudio(tts.audioBase64, res));
            }else{
              await speakWithWebSpeech(text);
            }
          }catch(_){
            await speakWithWebSpeech(text);
          }
        })();

        // Visual closeouts on a timer
        setTimeout(()=>{
          if(currentView==='context'){ ctxWrap.classList.remove('active'); }
          outputContainer.classList.remove('active');
          glassesBtn.classList.remove('show');
          clearWorkTag();
          setTimeout(closeDoor, 500);
        }, Math.max(CTX_LINGER_MS, BUBBLE_LINGER_MS - SHOW_CTX_AFTER_MS));

      }catch(e){
        console.error('summon hard error', e);
        const fallback = "geez I'm sorry I ugh, need a few more seconds. try again and I'll be right back.";
        const text = sanitize(fallback);
        typeOut(text, async ()=>{
          try{
            const tts = await fetchTTS(text);
            if(tts && tts.audioBase64){
              await new Promise(res=>playAudio(tts.audioBase64, res));
            }else{
              await speakWithWebSpeech(text);
            }
          }catch(_){
            await speakWithWebSpeech(text);
          }
          setTimeout(()=>{ outputContainer.classList.remove('active'); clearWorkTag(); setTimeout(closeDoor, 400); }, 400);
        });
      }
    })();
  }

  doorTrigger.addEventListener('click', summon);
  doorTrigger.addEventListener('keydown', e=>{ if(e.key===' '||e.key==='Enter'){ e.preventDefault(); summon(e); } });

  // calibration (unchanged)
  const calHud=document.getElementById('calHud'); let calOn=false; const STORAGE_KEY='cc_vars';
  function getVar(name,fallback){ const v=parseFloat(getComputedStyle(document.documentElement).getPropertyValue(name)); return isNaN(v)?(fallback??0):v; }
  function setVar(name,value){ document.documentElement.style.setProperty(name,String(value)); persistVars(); positionDoorAndChunklet(); updateHud(); }
  function persistVars(){
    const data={ door_x:getVar('--door-x'), door_y:getVar('--door-y'), door_w:getVar('--door-w'), door_h:getVar('--door-h'),
      mouth_top:getComputedStyle(document.documentElement).getPropertyValue('--mouth-top'),
      mouth_left:getComputedStyle(document.documentElement).getPropertyValue('--mouth-left'),
      eye_top:getComputedStyle(document.documentElement).getPropertyValue('--eye-top'),
      eye_gap:getComputedStyle(document.documentElement).getPropertyValue('--eye-gap'),
      eye_size:getComputedStyle(document.documentElement).getPropertyValue('--eye-size') };
    localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
  }
  function loadVars(){
    try{
      const raw=localStorage.getItem(STORAGE_KEY); if(!raw) return;
      const d=JSON.parse(raw);
      if(d.door_x) document.documentElement.style.setProperty('--door-x', d.door_x);
      if(d.door_y) document.documentElement.style.setProperty('--door-y', d.door_y);
      if(d.door_w) document.documentElement.style.setProperty('--door-w', d.door_w);
      if(d.door_h) document.documentElement.style.setProperty('--door-h', d.door_h);
      if(d.mouth_top)  document.documentElement.style.setProperty('--mouth-top', d.mouth_top);
      if(d.mouth_left) document.documentElement.style.setProperty('--mouth-left', d.mouth_left);
      if(d.eye_top)  document.documentElement.style.setProperty('--eye-top', d.eye_top);
      if(d.eye_gap)  document.documentElement.style.setProperty('--eye-gap', d.eye_gap);
      if(d.eye_size) document.documentElement.style.setProperty('--eye-size', d.eye_size);
    }catch(_){}
  }
  function updateHud(){
    if(!calOn) return;
    const door={ x:getVar('--door-x').toFixed(3), y:getVar('--door-y').toFixed(3), w:getVar('--door-w').toFixed(3), h:getVar('--door-h').toFixed(3) };
    const mTop=getComputedStyle(document.documentElement).getPropertyValue('--mouth-top').trim();
    const mLeft=getComputedStyle(document.documentElement).getPropertyValue('--mouth-left').trim();
    const eTop=getComputedStyle(document.documentElement).getPropertyValue('--eye-top').trim();
    const eGap=getComputedStyle(document.documentElement).getPropertyValue('--eye-gap').trim();
    const eSize=getComputedStyle(document.documentElement).getPropertyValue('--eye-size').trim();
    calHud.textContent=
`CALIBRATION — Shift=fine
Door  x:${door.x}  y:${door.y}  w:${door.w}  h:${door.h}
Mouth top:${mTop}  left:${mLeft}
Eyes top:${eTop}  gap:${eGap}  size:${eSize}
C=toggle  R=reset`;
  }
  function toggleCal(){ calOn=!calOn; calHud.classList.toggle('on', calOn); updateHud(); }
  function resetSaved(){ localStorage.removeItem(STORAGE_KEY); location.reload(); }
  loadVars();
  window.addEventListener('keydown', (e)=>{
    if(e.key==='c'||e.key==='C'){ toggleCal(); return; }
    if(!calOn) return;
    if(e.key==='r'||e.key==='R'){ resetSaved(); return; }
  });

  positionDoorAndChunklet();
})();
</script>
</body>
</html>
